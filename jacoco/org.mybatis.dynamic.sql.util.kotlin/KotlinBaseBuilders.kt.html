<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KotlinBaseBuilders.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MyBatis Dynamic SQL</a> &gt; <a href="index.source.html" class="el_package">org.mybatis.dynamic.sql.util.kotlin</a> &gt; <span class="el_source">KotlinBaseBuilders.kt</span></div><h1>KotlinBaseBuilders.kt</h1><pre class="source lang-java linenums">/*
 *    Copyright 2016-2024 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.mybatis.dynamic.sql.util.kotlin

import org.mybatis.dynamic.sql.AndOrCriteriaGroup
import org.mybatis.dynamic.sql.SqlTable
import org.mybatis.dynamic.sql.configuration.StatementConfiguration
import org.mybatis.dynamic.sql.select.AbstractQueryExpressionDSL
import org.mybatis.dynamic.sql.where.AbstractWhereStarter

@Target(AnnotationTarget.CLASS, AnnotationTarget.TYPE)
@DslMarker
annotation class MyBatisDslMarker

@Deprecated(&quot;Please use GroupingCriteriaCollector.where&quot;)
typealias WhereApplier = KotlinBaseBuilder&lt;*&gt;.() -&gt; Unit

@Deprecated(&quot;Please use GroupingCriteriaCollector.where&quot;)
<span class="fc" id="L32">fun WhereApplier.andThen(after: WhereApplier): WhereApplier = {</span>
<span class="fc" id="L33">    invoke(this)</span>
<span class="fc" id="L34">    after(this)</span>
<span class="fc" id="L35">}</span>

<span class="fc" id="L37">@MyBatisDslMarker</span>
@Suppress(&quot;TooManyFunctions&quot;)
<span class="fc" id="L39">abstract class KotlinBaseBuilder&lt;D : AbstractWhereStarter&lt;*,*&gt;&gt; {</span>

    fun configureStatement(c: StatementConfiguration.() -&gt; Unit) {
<span class="fc" id="L42">        getDsl().configureStatement(c)</span>
<span class="fc" id="L43">    }</span>

    fun where(criteria: GroupingCriteriaReceiver): Unit =
<span class="fc" id="L46">        GroupingCriteriaCollector().apply(criteria).let {</span>
<span class="fc" id="L47">            getDsl().where(it.initialCriterion, it.subCriteria)</span>
<span class="fc" id="L48">        }</span>

    fun where(criteria: List&lt;AndOrCriteriaGroup&gt;) {
<span class="fc" id="L51">        getDsl().where(criteria)</span>
<span class="fc" id="L52">    }</span>

    @Deprecated(&quot;Please move the \&quot;and\&quot; function into the where lambda. If the where lambda has more than one condition, you may need to surround the existing conditions with \&quot;group\&quot; first.&quot;)
    fun and(criteria: GroupingCriteriaReceiver): Unit =
<span class="fc" id="L56">        GroupingCriteriaCollector().apply(criteria).let {</span>
<span class="fc" id="L57">            getDsl().where().and(it.initialCriterion, it.subCriteria)</span>
<span class="fc" id="L58">        }</span>

    @Deprecated(&quot;Please move the \&quot;and\&quot; function into the where lambda. If the where lambda has more than one condition, you may need to surround the existing conditions with \&quot;group\&quot; first.&quot;)
    fun and(criteria: List&lt;AndOrCriteriaGroup&gt;) {
<span class="fc" id="L62">        getDsl().where().and(criteria)</span>
<span class="fc" id="L63">    }</span>

    @Deprecated(&quot;Please move the \&quot;or\&quot; function into the where lambda. If the where lambda has more than one condition, you may need to surround the existing conditions with \&quot;group\&quot; first.&quot;)
    fun or(criteria: GroupingCriteriaReceiver): Unit =
<span class="fc" id="L67">        GroupingCriteriaCollector().apply(criteria).let {</span>
<span class="fc" id="L68">            getDsl().where().or(it.initialCriterion, it.subCriteria)</span>
<span class="fc" id="L69">        }</span>

    @Deprecated(&quot;Please move the \&quot;or\&quot; function into the where lambda. If the where lambda has more than one condition, you may need to surround the existing conditions with \&quot;group\&quot; first.&quot;)
    fun or(criteria: List&lt;AndOrCriteriaGroup&gt;) {
<span class="fc" id="L73">        getDsl().where().or(criteria)</span>
<span class="fc" id="L74">    }</span>

    @Deprecated(&quot;Please use GroupingCriteriaCollector.where, then pass it to the \&quot;where\&quot; method&quot;)
<span class="fc" id="L77">    fun applyWhere(whereApplier: WhereApplier) = whereApplier.invoke(this)</span>

    /**
     * This function does nothing, but it can be used to make some code snippets more understandable.
     *
     * For example, to count all rows in a table you can write either of the following:
     *
     * val rows = countFrom(foo) { }
     *
     *    or
     *
     * val rows = countFrom(foo) { allRows() }
     */
    @SuppressWarnings(&quot;EmptyFunctionBlock&quot;)
    fun allRows() {
        // intentionally empty - this function exists for code beautification and clarity only
<span class="fc" id="L93">    }</span>

    protected abstract fun getDsl(): D
}

@Suppress(&quot;TooManyFunctions&quot;)
<span class="fc" id="L99">abstract class KotlinBaseJoiningBuilder&lt;D : AbstractQueryExpressionDSL&lt;*, *&gt;&gt; : KotlinBaseBuilder&lt;D&gt;() {</span>

    fun join(table: SqlTable, joinCriteria: JoinReceiver): Unit =
<span class="fc" id="L102">        applyToDsl(joinCriteria) { jc -&gt;</span>
<span class="fc" id="L103">            join(table, jc.onJoinCriterion(), jc.andJoinCriteria)</span>
<span class="fc" id="L104">        }</span>

    fun join(table: SqlTable, alias: String, joinCriteria: JoinReceiver): Unit =
<span class="fc" id="L107">        applyToDsl(joinCriteria) { jc -&gt;</span>
<span class="fc" id="L108">            join(table, alias, jc.onJoinCriterion(), jc.andJoinCriteria)</span>
<span class="fc" id="L109">        }</span>

    fun join(
        subQuery: KotlinQualifiedSubQueryBuilder.() -&gt; Unit,
        joinCriteria: JoinReceiver
    ): Unit =
<span class="fc" id="L115">        applyToDsl(subQuery, joinCriteria) { sq, jc -&gt;</span>
<span class="fc" id="L116">            join(sq, sq.correlationName, jc.onJoinCriterion(), jc.andJoinCriteria)</span>
<span class="fc" id="L117">        }</span>

    fun fullJoin(table: SqlTable, joinCriteria: JoinReceiver): Unit =
<span class="fc" id="L120">        applyToDsl(joinCriteria) { jc -&gt;</span>
<span class="fc" id="L121">            fullJoin(table, jc.onJoinCriterion(), jc.andJoinCriteria)</span>
<span class="fc" id="L122">        }</span>

    fun fullJoin(table: SqlTable, alias: String, joinCriteria: JoinReceiver): Unit =
<span class="fc" id="L125">        applyToDsl(joinCriteria) { jc -&gt;</span>
<span class="fc" id="L126">            fullJoin(table, alias, jc.onJoinCriterion(), jc.andJoinCriteria)</span>
<span class="fc" id="L127">        }</span>

    fun fullJoin(
        subQuery: KotlinQualifiedSubQueryBuilder.() -&gt; Unit,
        joinCriteria: JoinReceiver
    ): Unit =
<span class="fc" id="L133">        applyToDsl(subQuery, joinCriteria) { sq, jc -&gt;</span>
<span class="fc" id="L134">            fullJoin(sq, sq.correlationName, jc.onJoinCriterion(), jc.andJoinCriteria)</span>
<span class="fc" id="L135">        }</span>

    fun leftJoin(table: SqlTable, joinCriteria: JoinReceiver): Unit =
<span class="fc" id="L138">        applyToDsl(joinCriteria) { jc -&gt;</span>
<span class="fc" id="L139">            leftJoin(table, jc.onJoinCriterion(), jc.andJoinCriteria)</span>
<span class="fc" id="L140">        }</span>

    fun leftJoin(table: SqlTable, alias: String, joinCriteria: JoinReceiver): Unit =
<span class="fc" id="L143">        applyToDsl(joinCriteria) { jc -&gt;</span>
<span class="fc" id="L144">            leftJoin(table, alias, jc.onJoinCriterion(), jc.andJoinCriteria)</span>
<span class="fc" id="L145">        }</span>

    fun leftJoin(
        subQuery: KotlinQualifiedSubQueryBuilder.() -&gt; Unit,
        joinCriteria: JoinReceiver
    ): Unit =
<span class="fc" id="L151">        applyToDsl(subQuery, joinCriteria) { sq, jc -&gt;</span>
<span class="fc" id="L152">            leftJoin(sq, sq.correlationName, jc.onJoinCriterion(), jc.andJoinCriteria)</span>
<span class="fc" id="L153">        }</span>

    fun rightJoin(table: SqlTable, joinCriteria: JoinReceiver): Unit =
<span class="fc" id="L156">        applyToDsl(joinCriteria) { jc -&gt;</span>
<span class="fc" id="L157">            rightJoin(table, jc.onJoinCriterion(), jc.andJoinCriteria)</span>
<span class="fc" id="L158">        }</span>

    fun rightJoin(table: SqlTable, alias: String, joinCriteria: JoinReceiver): Unit =
<span class="fc" id="L161">        applyToDsl(joinCriteria) { jc -&gt;</span>
<span class="fc" id="L162">            rightJoin(table, alias, jc.onJoinCriterion(), jc.andJoinCriteria)</span>
<span class="fc" id="L163">        }</span>

    fun rightJoin(
        subQuery: KotlinQualifiedSubQueryBuilder.() -&gt; Unit,
        joinCriteria: JoinReceiver
    ): Unit =
<span class="fc" id="L169">        applyToDsl(subQuery, joinCriteria) { sq, jc -&gt;</span>
<span class="fc" id="L170">            rightJoin(sq, sq.correlationName, jc.onJoinCriterion(), jc.andJoinCriteria)</span>
<span class="fc" id="L171">        }</span>

    private fun applyToDsl(joinCriteria: JoinReceiver, applyJoin: D.(JoinCollector) -&gt; Unit) {
<span class="fc" id="L174">        getDsl().applyJoin(JoinCollector().apply(joinCriteria))</span>
<span class="fc" id="L175">    }</span>

    private fun applyToDsl(
        subQuery: KotlinQualifiedSubQueryBuilder.() -&gt; Unit,
        joinCriteria: JoinReceiver,
        applyJoin: D.(KotlinQualifiedSubQueryBuilder, JoinCollector) -&gt; Unit
    ) {
<span class="fc" id="L182">        getDsl().applyJoin(KotlinQualifiedSubQueryBuilder().apply(subQuery), JoinCollector().apply(joinCriteria))</span>
<span class="fc" id="L183">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>