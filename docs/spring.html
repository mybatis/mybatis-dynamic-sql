<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 1.11.1 from src/site/markdown/docs/spring.md at 21 April 2023
 | Rendered using Apache Maven Fluido Skin 1.11.1
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.11.1" />
    <title>MyBatis Dynamic SQL &#x2013; Spring Support</title>
    <link rel="stylesheet" href="../css/apache-maven-fluido-1.11.1.min.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
    <script src="../js/apache-maven-fluido-1.11.1.min.js"></script>
  </head>
  <body class="topBarDisabled">
    <div class="container-fluid">
      <header>
        <div id="banner">
          <div class="pull-left"><a href="../docs/introduction.html" id="bannerLeft"><h1>MyBatis Dynamic SQL</h1>
</a></div>
          <div class="pull-right"><a href="http://www.mybatis.org/" id="bannerRight" title="MyBatis logo"><img src="https://mybatis.org/images/mybatis-logo.png"  alt="MyBatis logo" style="" /></a></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 21 April 2023<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 1.5.0</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">User's Guide</li>
    <li><a href="../docs/introduction.html" title="Introduction"><span class="none"></span>Introduction</a></li>
    <li><a href="../docs/CHANGELOG.html" title="Change Log"><span class="none"></span>Change Log</a></li>
    <li><a href="../docs/quickStart.html" title="Quick Start"><span class="none"></span>Quick Start</a></li>
    <li><a href="../docs/exceptions.html" title="Exceptions thrown by the Library"><span class="none"></span>Exceptions thrown by the Library</a></li>
    <li><a href="../docs/configuration.html" title="Configuration of the Library"><span class="none"></span>Configuration of the Library</a></li>
    <li><a href="../docs/databaseObjects.html" title="Modeling Database Objects"><span class="none"></span>Modeling Database Objects</a></li>
    <li><a href="../docs/whereClauses.html" title="WHERE Clause Support"><span class="icon-chevron-down"></span>WHERE Clause Support</a>
     <ul class="nav nav-list">
      <li><a href="../docs/conditions.html" title="WHERE Conditions"><span class="none"></span>WHERE Conditions</a></li>
     </ul></li>
    <li><a href="../docs/select.html" title="SELECT Statements"><span class="icon-chevron-down"></span>SELECT Statements</a>
     <ul class="nav nav-list">
      <li><a href="../docs/complexQueries.html" title="Complex Queries"><span class="none"></span>Complex Queries</a></li>
     </ul></li>
    <li><a href="../docs/delete.html" title="DELETE Statements"><span class="none"></span>DELETE Statements</a></li>
    <li><a href="../docs/insert.html" title="INSERT Statements"><span class="none"></span>INSERT Statements</a></li>
    <li><a href="../docs/update.html" title="UPDATE Statements"><span class="none"></span>UPDATE Statements</a></li>
    <li><a href="../docs/subQueries.html" title="SubQuery Support"><span class="none"></span>SubQuery Support</a></li>
    <li><a href="../docs/functions.html" title="Database Functions"><span class="none"></span>Database Functions</a></li>
    <li><a href="../docs/mybatis3.html" title="MyBatis3 Support"><span class="none"></span>MyBatis3 Support</a></li>
    <li class="active"><a><span class="none"></span>Spring Support</a></li>
    <li><a href="../docs/springBatch.html" title="Spring Batch Support"><span class="none"></span>Spring Batch Support</a></li>
    <li><a href="../docs/kotlinOverview.html" title="Kotlin Support"><span class="icon-chevron-right"></span>Kotlin Support</a></li>
    <li><a href="../docs/howItWorks.html" title="How it Works"><span class="none"></span>How it Works</a></li>
    <li><a href="../docs/extending.html" title="Extending the Library"><span class="none"></span>Extending the Library</a></li>
    <li><a href="../docs/codingStandards.html" title="Coding Standards"><span class="none"></span>Coding Standards</a></li>
    <li><a href="../docs/motivation.html" title="Motivation"><span class="none"></span>Motivation</a></li>
   <li class="nav-header">Project Documentation</li>
    <li><a href="../project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="../project-reports.html" title="Project Reports"><span class="icon-chevron-right"></span>Project Reports</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="../images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn"  class="span10" >
<h1>Spring Support</h1>
<p>The library supports generating SQL that is compatible with the Spring Framework's named parameter JDBC templates.</p>
<p>The SQL statement objects are created in exactly the same way as for MyBatis - only the rendering strategy changes.  For example:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">    SelectStatementProvider selectStatement = select(id, firstName, lastName, fullName)
            .from(generatedAlways)
            .where(id, isGreaterThan(3))
            .orderBy(id.descending())
            .build()
            .render(RenderingStrategies.SPRING_NAMED_PARAMETER);
</code></pre></div>
<p>The generated SQL statement providers are compatible with Spring's <code>NamedParameterJdbcTemplate</code> in all cases. The only challenge comes with presenting statement parameters to Spring in the correct manner. To make this easier, the library provides a utility class <code>org.mybatis.dynamic.sql.util.spring.NamedParameterJdbcTemplateExtensions</code> that executes statements properly in all cases and hides the complexity of rendering statements and formatting parameters. All the examples below will show usage both with and without the utility class.</p><section>
<h2><a name="Type_Converters_for_Spring"></a>Type Converters for Spring</h2>
<p>Spring JDBC templates do not have the equivalent of a type handler in MyBatis3. This is generally not a problem in processing results because you can build type conversions into your row handler. If you were manually creating the parameter map that is used as input to a Spring template you could perform a type conversion there too. But when you use MyBatis Dynamic SQL, the parameters are generated by the library, so you do not have the opportunity to perform type conversions directly.</p>
<p>To address this issue, the library provides a parameter type converter that can be used to perform a type conversion before parameters are placed in a parameter map.</p>
<p>For example, suppose we want to use a <code>Boolean</code> in Java to represent the value of a flag, but in the database the corresponding field is a <code>CHAR</code> field that expects values &#x201c;true&#x201d; or &#x201c;false&#x201d;. This can be accomplished by using a <code>ParameterTypeConverter</code>. First create the converter as follows:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">public class TrueFalseParameterConverter implements ParameterTypeConverter&lt;Boolean, String&gt; {
    @Override
    public String convert(Boolean source) {
        return source == null ? null : source ? &quot;true&quot; : &quot;false&quot;;
    }
}
</code></pre></div>
<p>The type converter is compatible with Spring's existing Converter interface. Associate the type converter with a SqlColumn as follows:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">...
    public final SqlColumn&lt;Boolean&gt; employed = column(&quot;employed&quot;, JDBCType.VARCHAR)
            .withParameterTypeConverter(new TrueFalseParameterConverter());
...
</code></pre></div>
<p>MyBatis Dynamic SQL will now call the converter function before corresponding parameters are placed into the generated parameter map. The converter will be called in the following cases:</p>
<ol style="list-style-type: decimal">

<li>With a general insert statement when using the <code>set(...).toValue(...)</code> or <code>set(...).toValueWhenPresent(...)</code> mappings</li>
<li>With an update statement when using the <code>set(...).equalTo(...)</code> or <code>set(...).equalToWhenPresent(...)</code> mappings</li>
<li>With where clauses in any statement type that contain conditions referencing the field</li>
</ol></section><section>
<h2><a name="Executing_Select_Statements"></a>Executing Select Statements</h2>
<p>The Spring Named Parameter JDBC template expects an SQL statement with parameter markers in the Spring format, and a set of matched parameters.  MyBatis Dynamic SQL will generate both.  The parameters returned from the generated SQL statement can be wrapped in a Spring <code>MapSqlParameterSource</code>.  Spring also expects you to provide a row mapper for creating the returned objects.</p>
<p>The following code shows a complete example without the utility class:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">    NamedParameterJdbcTemplate template = getTemplate();  // not shown

    SelectStatementProvider selectStatement = select(id, firstName, lastName, fullName)
            .from(generatedAlways)
            .where(id, isGreaterThan(3))
            .orderBy(id.descending())
            .build()
            .render(RenderingStrategies.SPRING_NAMED_PARAMETER);
        
    SqlParameterSource namedParameters = new MapSqlParameterSource(selectStatement.getParameters());
    List&lt;GeneratedAlwaysRecord&gt; records = template.query(selectStatement.getSelectStatement(), namedParameters,
        (rs, rowNum) -&gt; {
            GeneratedAlwaysRecord record = new GeneratedAlwaysRecord();
            record.setId(rs.getInt(1));
            record.setFirstName(rs.getString(2));
            record.setLastName(rs.getString(3));
            record.setFullName(rs.getString(4));
            return record;
        });
</code></pre></div>
<p>The following code shows a complete example with the utility class:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">    NamedParameterJdbcTemplate template = getTemplate();  // not shown
    NamedParameterJdbcTemplateExtensions extensions = new NamedParameterJdbcTemplateExtensions(template);

    Buildable&lt;SelectModel&gt; selectStatement = select(id, firstName, lastName, fullName)
            .from(generatedAlways)
            .where(id, isGreaterThan(3))
            .orderBy(id.descending());
        
    List&lt;GeneratedAlwaysRecord&gt; records = extensions.selectList(selectStatement,
        (rs, rowNum) -&gt; {
            GeneratedAlwaysRecord record = new GeneratedAlwaysRecord();
            record.setId(rs.getInt(1));
            record.setFirstName(rs.getString(2));
            record.setLastName(rs.getString(3));
            record.setFullName(rs.getString(4));
            return record;
        });
</code></pre></div>
<p>The utility class also includes a <code>selectOne</code> method that returns an <code>Optional</code>. An example is shown below:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">    NamedParameterJdbcTemplate template = getTemplate();  // not shown
    NamedParameterJdbcTemplateExtensions extensions = new NamedParameterJdbcTemplateExtensions(template);

    Buildable&lt;SelectModel&gt; selectStatement = select(id, firstName, lastName, fullName)
            .from(generatedAlways)
            .where(id, isEqualTo(3));
        
    Optional&lt;GeneratedAlwaysRecord&gt; record = extensions.selectOne(selectStatement,
        (rs, rowNum) -&gt; {
            GeneratedAlwaysRecord record = new GeneratedAlwaysRecord();
            record.setId(rs.getInt(1));
            record.setFirstName(rs.getString(2));
            record.setLastName(rs.getString(3));
            record.setFullName(rs.getString(4));
            return record;
        });
</code></pre></div></section><section>
<h2><a name="Executing_Insert_Statements"></a>Executing Insert Statements</h2>
<p>The library generates several types of insert statements. See the <a href="insert.html">Insert Statements</a> page for details.</p>
<p>Spring supports retrieval of generated keys for many types of inserts. This library has support for generated key retrieval where it is supported by Spring.</p><section>
<h3><a name="Executing_General_Insert_Statements"></a>Executing General Insert Statements</h3>
<p>General insert statements do not require a POJO object matching a table row. Following is a complete example:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">    NamedParameterJdbcTemplate template = getTemplate();  // not shown

    GeneralInsertStatementProvider insertStatement = insertInto(generatedAlways)
            .set(id).toValue(100)
            .set(firstName).toValue(&quot;Bob&quot;)
            .set(lastName).toValue(&quot;Jones&quot;)
            .build()
            .render(RenderingStrategies.SPRING_NAMED_PARAMETER);

    int rows = template.update(insertStatement.getInsertStatement(), insertStatement.getParameters());
</code></pre></div>
<p>If you want to retrieve generated keys for a general insert statement the steps are similar except that you must wrap the parameters in a <code>MapSqlParameterSource</code> object and use a <code>GeneratedKeyHolder</code>. Following is a complete example of this usage:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">    NamedParameterJdbcTemplate template = getTemplate();  // not shown

    GeneralInsertStatementProvider insertStatement = insertInto(generatedAlways)
            .set(id).toValue(100)
            .set(firstName).toValue(&quot;Bob&quot;)
            .set(lastName).toValue(&quot;Jones&quot;)
            .build()
            .render(RenderingStrategies.SPRING_NAMED_PARAMETER);

    MapSqlParameterSource parameterSource = new MapSqlParameterSource(insertStatement.getParameters());
    KeyHolder keyHolder = new GeneratedKeyHolder();

    int rows = template.update(insertStatement.getInsertStatement(), parameterSource, keyHolder);
    String generatedKey = (String) keyHolder.getKeys().get(&quot;FULL_NAME&quot;);
</code></pre></div>
<p>This can be simplified by using the utility class as follows:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">    NamedParameterJdbcTemplate template = getTemplate();  // not shown
    NamedParameterJdbcTemplateExtensions extensions = new NamedParameterJdbcTemplateExtensions(template);

    Buildable&lt;GeneralInsertModel&gt; insertStatement = insertInto(generatedAlways)
            .set(id).toValue(100)
            .set(firstName).toValue(&quot;Bob&quot;)
            .set(lastName).toValue(&quot;Jones&quot;);
    
    // no generated key retrieval
    int rows = extensions.generalInsert(insertStatement);

    // retrieve generated keys
    KeyHolder keyHolder = new GeneratedKeyHolder();
    int rows = extensions.generalInsert(insertStatement, keyHolder);
</code></pre></div></section><section>
<h3><a name="Executing_Single_Record_Insert_Statements"></a>Executing Single Record Insert Statements</h3>
<p>Insert record statements are a bit different - MyBatis Dynamic SQL generates a properly formatted SQL string for Spring, but instead of a map of parameters, the parameter mappings are created for the inserted record itself.  So the parameters for the Spring template are created by a <code>BeanPropertySqlParameterSource</code>.  Generated keys in Spring are supported with a <code>GeneratedKeyHolder</code>.  The following is a complete example:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">    NamedParameterJdbcTemplate template = getTemplate();  // not shown

    GeneratedAlwaysRecord record = new GeneratedAlwaysRecord();
    record.setId(100);
    record.setFirstName(&quot;Bob&quot;);
    record.setLastName(&quot;Jones&quot;);
        
    InsertStatementProvider&lt;GeneratedAlwaysRecord&gt; insertStatement = insert(record)
            .into(generatedAlways)
            .map(id).toProperty(&quot;id&quot;)
            .map(firstName).toProperty(&quot;firstName&quot;)
            .map(lastName).toProperty(&quot;lastName&quot;)
            .build()
            .render(RenderingStrategies.SPRING_NAMED_PARAMETER);
        
    SqlParameterSource parameterSource = new BeanPropertySqlParameterSource(insertStatement.getRecord());
    KeyHolder keyHolder = new GeneratedKeyHolder();
        
    int rows = template.update(insertStatement.getInsertStatement(), parameterSource, keyHolder);
    String generatedKey = (String) keyHolder.getKeys().get(&quot;FULL_NAME&quot;);
</code></pre></div>
<p>This can be simplified by using the utility class as follows:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">    NamedParameterJdbcTemplate template = getTemplate();  // not shown
    NamedParameterJdbcTemplateExtensions extensions = new NamedParameterJdbcTemplateExtensions(template);

    GeneratedAlwaysRecord record = new GeneratedAlwaysRecord();
    record.setId(100);
    record.setFirstName(&quot;Bob&quot;);
    record.setLastName(&quot;Jones&quot;);
        
    Buildable&lt;InsertModel&lt;GeneratedAlwaysRecord&gt;&gt; insertStatement = insert(record)
            .into(generatedAlways)
            .map(id).toProperty(&quot;id&quot;)
            .map(firstName).toProperty(&quot;firstName&quot;)
            .map(lastName).toProperty(&quot;lastName&quot;);
    
    // no generated key retrieval
    int rows = extensions.insert(insertStatement);

    // retrieve generated keys
    KeyHolder keyHolder = new GeneratedKeyHolder();
    int rows = extensions.insert(insertStatement, keyHolder);
</code></pre></div></section><section>
<h3><a name="Multi-Row_Inserts"></a>Multi-Row Inserts</h3>
<p>A multi-row insert is a single insert statement with multiple VALUES clauses. This can be a convenient way in insert a small number of records into a table with a single statement. Note however that a multi-row insert is not suitable for large bulk inserts as it is possible to exceed the limit of prepared statement parameters with a large number of records. For that use case, use a batch insert (see below).</p>
<p>With multi-row insert statements MyBatis Dynamic SQL generates a properly formatted SQL string for Spring. Instead of a map of parameters, the multiple records are stored in the generated provider object and the parameter mappings are created for the generated provider itself. The parameters for the Spring template are created by a <code>BeanPropertySqlParameterSource</code>.  Generated keys in Spring are supported with a <code>GeneratedKeyHolder</code>.  The following is a complete example:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">    NamedParameterJdbcTemplate template = getTemplate();  // not shown

    List&lt;GeneratedAlwaysRecord&gt; records = new ArrayList&lt;&gt;();
    GeneratedAlwaysRecord record = new GeneratedAlwaysRecord();
    record.setId(100);
    record.setFirstName(&quot;Bob&quot;);
    record.setLastName(&quot;Jones&quot;);
    records.add(record);
        
    record = new GeneratedAlwaysRecord();
    record.setId(101);
    record.setFirstName(&quot;Jim&quot;);
    record.setLastName(&quot;Smith&quot;);
    records.add(record);

    MultiRowInsertStatementProvider&lt;GeneratedAlwaysRecord&gt; insertStatement = insertMultiple(records).into(generatedAlways)
            .map(id).toProperty(&quot;id&quot;)
            .map(firstName).toProperty(&quot;firstName&quot;)
            .map(lastName).toProperty(&quot;lastName&quot;)
            .build()
            .render(RenderingStrategies.SPRING_NAMED_PARAMETER);

    SqlParameterSource parameterSource = new BeanPropertySqlParameterSource(insertStatement);
    KeyHolder keyHolder = new GeneratedKeyHolder();
        
    int rows = template.update(insertStatement.getInsertStatement(), parameterSource, keyHolder);
    String firstGeneratedKey = (String) keyHolder.getKeyList().get(0).get(&quot;FULL_NAME&quot;);
    String secondGeneratedKey = (String) keyHolder.getKeyList().get(1).get(&quot;FULL_NAME&quot;);
</code></pre></div>
<p>This can be simplified by using the utility class as follows:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">    NamedParameterJdbcTemplate template = getTemplate();  // not shown
    NamedParameterJdbcTemplateExtensions extensions = new NamedParameterJdbcTemplateExtensions(template);

    List&lt;GeneratedAlwaysRecord&gt; records = new ArrayList&lt;&gt;();
    GeneratedAlwaysRecord record = new GeneratedAlwaysRecord();
    record.setId(100);
    record.setFirstName(&quot;Bob&quot;);
    record.setLastName(&quot;Jones&quot;);
    records.add(record);
        
    record = new GeneratedAlwaysRecord();
    record.setId(101);
    record.setFirstName(&quot;Jim&quot;);
    record.setLastName(&quot;Smith&quot;);
    records.add(record);

    Buildable&lt;MultiRowInsertModel&lt;GeneratedAlwaysRecord&gt;&gt; insertStatement = insertMultiple(records).into(generatedAlways)
            .map(id).toProperty(&quot;id&quot;)
            .map(firstName).toProperty(&quot;firstName&quot;)
            .map(lastName).toProperty(&quot;lastName&quot;);

    // no generated key retrieval
    int rows = extensions.insertMultiple(insertStatement);

    // retrieve generated keys
    KeyHolder keyHolder = new GeneratedKeyHolder();
    int rows = extensions.insertMultiple(insertStatement, keyHolder);
</code></pre></div></section><section>
<h3><a name="Executing_Batch_Inserts"></a>Executing Batch Inserts</h3>
<p>A JDBC batch insert is an efficient way to perform a bulk insert. It does not have the limitations of a multi-row insert and may perform better too. Spring does not support returning generated keys from a batch insert.  The following is a complete example of a batch insert (note the use of <code>SqlParameterSourceUtils</code> to create an array of parameter sources from an array of input records):</p>

<div class="source"><pre class="prettyprint"><code class="language-java">    NamedParameterJdbcTemplate template = getTemplate();  // not shown

    List&lt;GeneratedAlwaysRecord&gt; records = new ArrayList&lt;&gt;();
    GeneratedAlwaysRecord record = new GeneratedAlwaysRecord();
    record.setId(100);
    record.setFirstName(&quot;Bob&quot;);
    record.setLastName(&quot;Jones&quot;);
    records.add(record);
        
    record = new GeneratedAlwaysRecord();
    record.setId(101);
    record.setFirstName(&quot;Jim&quot;);
    record.setLastName(&quot;Smith&quot;);
    records.add(record);

    SqlParameterSource[] batch = SqlParameterSourceUtils.createBatch(records.toArray());
        
    BatchInsert&lt;GeneratedAlwaysRecord&gt; batchInsert = insert(records)
            .into(generatedAlways)
            .map(id).toProperty(&quot;id&quot;)
            .map(firstName).toProperty(&quot;firstName&quot;)
            .map(lastName).toProperty(&quot;lastName&quot;)
            .build()
            .render(RenderingStrategies.SPRING_NAMED_PARAMETER);
        
    int[] updateCounts = template.batchUpdate(batchInsert.getInsertStatementSQL(), batch);
</code></pre></div>
<p>This can be simplified by using the utility class as follows:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">    NamedParameterJdbcTemplate template = getTemplate();  // not shown
    NamedParameterJdbcTemplateExtensions extensions = new NamedParameterJdbcTemplateExtensions(template);

    List&lt;GeneratedAlwaysRecord&gt; records = new ArrayList&lt;&gt;();
    GeneratedAlwaysRecord record = new GeneratedAlwaysRecord();
    record.setId(100);
    record.setFirstName(&quot;Bob&quot;);
    record.setLastName(&quot;Jones&quot;);
    records.add(record);
        
    record = new GeneratedAlwaysRecord();
    record.setId(101);
    record.setFirstName(&quot;Jim&quot;);
    record.setLastName(&quot;Smith&quot;);
    records.add(record);

    Buildable&lt;BatchInsertModel&lt;GeneratedAlwaysRecord&gt;&gt; insertStatement = insertBatch(records)
            .into(generatedAlways)
            .map(id).toProperty(&quot;id&quot;)
            .map(firstName).toProperty(&quot;firstName&quot;)
            .map(lastName).toProperty(&quot;lastName&quot;);
        
    int[] updateCounts = extensions.insertBatch(insertStatement);
</code></pre></div></section></section><section>
<h2><a name="Executing_Delete_Statements"></a>Executing Delete Statements</h2>
<p>Delete statements use the <code>MapSqlParameterSource</code> as with select statements, but use the <code>update</code> method in the template.  For example:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">    NamedParameterJdbcTemplate template = getTemplate();  // not shown

    DeleteStatementProvider deleteStatement = deleteFrom(generatedAlways)
            .where(id,  isLessThan(3))
            .build()
            .render(RenderingStrategies.SPRING_NAMED_PARAMETER);
        
    SqlParameterSource parameterSource = new MapSqlParameterSource(deleteStatement.getParameters());
        
    int rows = template.update(deleteStatement.getDeleteStatement(), parameterSource);
</code></pre></div>
<p>This can be simplified by using the utility class as follows:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">    NamedParameterJdbcTemplate template = getTemplate();  // not shown
    NamedParameterJdbcTemplateExtensions extensions = new NamedParameterJdbcTemplateExtensions(template);

    Buildable&lt;DeleteModel&gt; deleteStatement = deleteFrom(generatedAlways)
            .where(id,  isLessThan(3));
        
    int rows = extensions.delete(deleteStatement);
</code></pre></div></section><section>
<h2><a name="Executing_Update_Statements"></a>Executing Update Statements</h2>
<p>Update statements use the <code>MapSqlParameterSource</code> as with select statements, but use the <code>update</code> method in the template.  For example:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">    NamedParameterJdbcTemplate template = getTemplate();  // not shown

    UpdateStatementProvider updateStatement = update(generatedAlways)
            .set(firstName).equalToStringConstant(&quot;Rob&quot;)
            .where(id, isIn(1, 5, 22))
            .build()
            .render(RenderingStrategies.SPRING_NAMED_PARAMETER);
        
    SqlParameterSource parameterSource = new MapSqlParameterSource(updateStatement.getParameters());
        
    int rows = template.update(updateStatement.getUpdateStatement(), parameterSource);
</code></pre></div>
<p>This can be simplified by using the utility class as follows:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">    NamedParameterJdbcTemplate template = getTemplate();  // not shown
    NamedParameterJdbcTemplateExtensions extensions = new NamedParameterJdbcTemplateExtensions(template);

    Buildable&lt;UpdateModel&gt; updateStatement = update(generatedAlways)
            .set(firstName).equalToStringConstant(&quot;Rob&quot;)
            .where(id, isIn(1, 5, 22));
        
    int rows = extensions.update(updateStatement);
</code></pre></div></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>&#169;      2016&#x2013;2023
<a href="https://www.mybatis.org/">MyBatis.org</a>
</p>
        </div>
      </div>
    </footer>
<script>
	if(anchors) {
	  anchors.add();
	}
</script>
  </body>
</html>
