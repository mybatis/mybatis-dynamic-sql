<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 2.0.0 from src/site/markdown/docs/kotlinWhereClauses.md at 27 May 2025
 | Rendered using Apache Maven Fluido Skin 2.1.0
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 2.0.0" />
    <title>Kotlin Where Clauses â€“ MyBatis Dynamic SQL</title>
    <link rel="stylesheet" href="../css/apache-maven-fluido-2.1.0.min.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
    <script src="../js/apache-maven-fluido-2.1.0.min.js"></script>
  </head>
  <body>
    <div class="container-fluid container-fluid-top">
      <header>
        <div id="banner">
          <div class="pull-left"><div id="bannerLeft"><h1><a href="../docs/introduction.html">MyBatis Dynamic SQL</a></h1></div></div>
          <div class="pull-right"><div id="bannerRight"><h1><a href="http://www.mybatis.org/"><img src="https://mybatis.org/images/mybatis-logo.png" alt="MyBatis logo" /> MyBatis</a></h1></div></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 03 Jun 2024<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 2.0.0-SNAPSHOT</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">User&apos;s Guide</li>
    <li><a href="../docs/introduction.html">Introduction</a></li>
    <li><a href="../docs/CHANGELOG.html">Change Log</a></li>
    <li><a href="../docs/migratingV1toV2.html">Migrating from V1 to V2</a></li>
    <li><a href="../docs/quickStart.html">Quick Start</a></li>
    <li><a href="../docs/exceptions.html">Exceptions thrown by the Library</a></li>
    <li><a href="../docs/configuration.html">Configuration of the Library</a></li>
    <li><a href="../docs/databaseObjects.html">Modeling Database Objects</a></li>
    <li><a href="../docs/whereClauses.html"><span class="icon-chevron-down"></span>WHERE Clause Support</a>
     <ul class="nav nav-list">
      <li><a href="../docs/conditions.html">WHERE Conditions</a></li>
     </ul></li>
    <li><a href="../docs/select.html"><span class="icon-chevron-down"></span>SELECT Statements</a>
     <ul class="nav nav-list">
      <li><a href="../docs/caseExpressions.html">Case Expressions</a></li>
      <li><a href="../docs/complexQueries.html">Complex Queries</a></li>
     </ul></li>
    <li><a href="../docs/delete.html">DELETE Statements</a></li>
    <li><a href="../docs/insert.html">INSERT Statements</a></li>
    <li><a href="../docs/update.html">UPDATE Statements</a></li>
    <li><a href="../docs/subQueries.html">SubQuery Support</a></li>
    <li><a href="../docs/functions.html">Database Functions</a></li>
    <li><a href="../docs/mybatis3.html">MyBatis3 Support</a></li>
    <li><a href="../docs/spring.html">Spring Support</a></li>
    <li><a href="../docs/springBatch.html">Spring Batch Support</a></li>
    <li><a href="../docs/kotlinOverview.html"><span class="icon-chevron-down"></span>Kotlin Support</a>
     <ul class="nav nav-list">
      <li><a href="../docs/kotlinCaseExpressions.html">Kotlin Case Expressions</a></li>
      <li class="active"><a>Kotlin Where Clauses</a></li>
      <li><a href="../docs/kotlinMyBatis3.html">Kotlin Support for MyBatis3</a></li>
      <li><a href="../docs/kotlinSpring.html">Kotlin Support for Spring</a></li>
     </ul></li>
    <li><a href="../docs/howItWorks.html">How it Works</a></li>
    <li><a href="../docs/extending.html">Extending the Library</a></li>
    <li><a href="../docs/codingStandards.html">Coding Standards</a></li>
    <li><a href="../docs/motivation.html">Motivation</a></li>
   <li class="nav-header">Project Documentation</li>
    <li><a href="../project-info.html"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="../project-reports.html"><span class="icon-chevron-right"></span>Project Reports</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
<a href="https://maven.apache.org/" class="builtBy" target="_blank"><img class="builtBy" alt="Built by Maven" src="../images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn" class="span10">
<section><a id="Kotlin_Where_Clauses"></a>
<h1>Kotlin Where Clauses</h1>
<p>Where clauses can be supplied to delete, select, and update statements. The Kotlin DSL provides an implementation
of a where clause that looks very close to natural SQL. This is accomplished through a combination of operator
overload functions, infix functions, and Kotlin receiver functions.</p><section><a id="Simple_Where_Clauses"></a>
<h2>Simple Where Clauses</h2>
<p>The simplest form of where clause includes a single condition. See the following examples:</p>

<pre class="prettyprint"><code class="language-kotlin">select(foo) {
    from(bar)
    where { id isEqualTo 3 }
}

select(foo) {
    from(bar)
    where { id isBetween 3 and 7 }
}
</code></pre>
<p>In this case, <code>id</code> is an SqlColumn of type Integer, <code>isEqualTo</code> and <code>isBetween</code> are infix functions. These clauses can
also be written as follows by explicitly calling each function:</p>

<pre class="prettyprint"><code class="language-kotlin">select(foo) {
    from(bar)
    where { id.isEqualTo(3) }
}

select(foo) {
    from(bar)
    where { id.isBetween(3).and(7) }
}
</code></pre>
<p>Most, but not all, of the built-in conditions can be expressed as infix functions. Conditions without parameters,
or varargs conditions, cannot be called as an infix function. Good examples of conditions that cannot be called via
an infix function are <code>isNull</code> and <code>isIn</code>. In those cases you will need to call the function directly as follows:</p>

<pre class="prettyprint"><code class="language-kotlin">select(foo) {
    from(bar)
    where { id.isNull() }
}

select(foo) {
    from(bar)
    where { id.isIn(1, 2, 3) }
}
</code></pre></section><section><a id="Using_Filter_and_Map"></a>
<h2>Using Filter and Map</h2>
<p>Many conditions support <code>filter</code> and <code>map</code> functions that can be used to test whether the condition should be rendered
or to change the value of the condition parameter(s). If you need to use the <code>filter</code> or <code>map</code> functions, then you
cannot use the infix functions. In this case you can use a function that creates the condition and then apply
that condition to the where clause via the invoke operator. For example:</p>

<pre class="prettyprint"><code class="language-kotlin">select(foo) {
    from(bar)
    where { firstName (isLike(&quot;fred&quot;).map { &quot;%$it%&quot; }) } // add wildcards for like
}
</code></pre>
<p>In this case, <code>isLike</code> is a function in the <code>org.mybatis.dynamic.sql.util.kotlin.elements</code> package, not the infix
function. Note also that the condition is enclosed in parentheses. This is actually a function call using a Kotlin
invoke operator overload. This can also be called explicitly without the operator overload as follows:</p>

<pre class="prettyprint"><code class="language-kotlin">select(foo) {
    from(bar)
    where { firstName.invoke(isLike(&quot;fred&quot;).map { &quot;%$it%&quot; }) } // add wildcards for like
}
</code></pre></section><section><a id="Compound_Where_Clauses"></a>
<h2>Compound Where Clauses</h2>
<p>Of course many where clauses are composed of more than one condition. The where DSL supports arbitrarily complex
where clauses with and/or/not phrases. See the following example of a complex where clause:</p>

<pre class="prettyprint"><code class="language-kotlin">select(foo) {
    from(bar)
    where {
       id isEqualTo 3
       or { id isEqualTo 4 }
       and { not { id isEqualTo 6 } }
    }
}
</code></pre>
<p>The <code>and</code>, <code>or</code>, and <code>not</code> functions each create a new context that can in turn include <code>and</code>, <code>or</code>, and <code>not</code>
functions. The DSL has no practical limit on the depth of nesting of these functions. When there are nested
<code>and</code> and <code>or</code> functions, the curly braces will be rendered as parentheses in the final SQL if the context contains
more than one condition.</p></section><section><a id="Initial_and_Subsequent_Conditions"></a>
<h2>Initial and Subsequent Conditions</h2>
<p>As shown above, the <code>where</code>, <code>and</code>, <code>or</code>, <code>not</code>, and <code>group</code> functions create a context where conditions can be
specified (<code>group</code> is detailed below). Every context supports two types of conditions:</p>
<ol style="list-style-type: decimal;">

<li>A single initial condition (like <code>id isEqualTo 3</code>). If you specify more than one initial condition, the library
will throw a runtime exception. There are multiple types of initial conditions detailed below.</li>
<li>Any number of subsequent conditions created by the <code>and</code> or <code>or</code> functions</li>
</ol>
<p>Everything is optional - if you don't specify an initial condition, or any subsequent conditions, then nothing will
render.</p>
<p>For each context, the renderer will add parenthesis around the rendered context if there is more than one condition in
the context. Remember that a <code>filter</code> function can be used to remove some conditions from rendering, so the
parentheses are added only if there is more than one condition that renders.</p>
<p>If you neglect to specify an initial condition and only specify <code>and</code> and <code>or</code> groups, then the first &#x201c;and&#x201d; or &#x201c;or&#x201d;
will be removed during rendering. This to avoid a rendered where clause like &#x201c;where and id = 3&#x201d;. This can be useful
in situations where a where clause is composed by a number of different functions - there is no need to keep track
of who goes first as the renderer will automatically strip the first connector.</p><section><a id="Initial_Condition_Types"></a>
<h3>Initial Condition Types</h3>
<p>There are four types of initial conditions. Only one of the initial condition types may be specified in any
given context. Others must be enclosed in an <code>and</code> or an <code>or</code> block. The four types are as follows:</p>
<ol style="list-style-type: decimal;">

<li>
<p><strong>Column and Criterion</strong> - either with the infix functions, or the invoke function as shown above</p></li>
<li>
<p><strong>Not</strong> - appends &#x201c;not&#x201d; to a group of criteria or a single criterion as shown above</p></li>
<li>
<p><strong>Exists</strong> - for executing an exists sub-query:</p>

<pre class="prettyprint"><code class="language-kotlin">select(foo) {
    from(bar)
    where {
        exists {
            select(foo.allColumns())
            from(foo)
            where { foo.id isEqualTo bar.fooId }
        }
    }
}
</code></pre>
<p>You can accomplish a &#x201c;not exists&#x201d; by nesting <code>exists</code> inside a <code>not</code> block:</p>

<pre class="prettyprint"><code class="language-kotlin">select(foo) {
    from(bar)
    where { not {
        exists {
            select(foo.allColumns())
            from(foo)
            where { foo.id isEqualTo bar.fooId }
        }
    }}
}
</code></pre></li>
<li>
<p><strong>Group</strong> - for grouping conditions with parentheses:</p>

<pre class="prettyprint"><code class="language-kotlin">select(foo) {
    from(bar)
    where {
        group {
            id isEqualTo 3
            and { id isEqualTo 4 }
        }
        or { firstName.isNull() }
    }
}
</code></pre>
<p>The <code>group</code> function is used to insert parentheses around a group of conditions before
and <code>and</code> or an <code>or</code>.</p></li>
</ol></section></section><section><a id="Extending_Where_Clauses"></a>
<h2>Extending Where Clauses</h2>
<p>In addition to the built-in conditions supplied with the library, it is also possible to write your own custom
conditions. Any custom condition can be used with the &#x201c;invoke operator&#x201d; method shown above in the
&#x201c;Using Filter And Map&#x201d; section above.</p>
<p>At this time, it is not possible to add infix functions for custom conditions to the library. This is due to an
underlying limitation in Kotlin itself. There is a Kotlin language enhancement on the roadmap that will likely
remove this limitation. That enhancement will allow multiple receivers for an extension function. You can follow
progress of that enhancement here: <a href="https://youtrack.jetbrains.com/issue/KT-42435" class="externalLink">https://youtrack.jetbrains.com/issue/KT-42435</a></p></section><section><a id="Migrating_from_Prior_Releases"></a>
<h2>Migrating from Prior Releases</h2>
<p>In version 1.4.0 the where DSL improved significantly and is now implemented as shown on this page. Many methods from
previous releases are now deprecated. One of the primary motivations for this change was that compound criteria
from prior releases were difficult to reason about - the Kotlin syntax was very different from the generated SQL.
In complex where clauses, the code could become very difficult to understand.</p>
<p>With the updated DSL, the Kotlin code is much closer to the generated SQL and there is a consistent use of curly braces
to denote where parentheses should be generated in SQL.</p>
<p>This section will detail the patterns for code updates from prior releases to the new DSL. The patterns below apply
equally to &#x201c;where&#x201d;, &#x201c;and&#x201d;, and &#x201c;or&#x201d; methods from the prior releases.</p><section><a id="Migrating_Single_Column_and_Condition"></a>
<h3>Migrating Single Column and Condition</h3>
<p>In prior releases, a criterion with a single column and condition was written as follows:</p>

<pre class="prettyprint"><code class="language-kotlin">select(foo) {
   from(bar)
   where(id, isEqualTo(3))
   or(id, isEqualTo(4))
}
</code></pre>
<p>These criteria should be updated by moving the column and condition into a lambda and using an infix function:</p>

<pre class="prettyprint"><code class="language-kotlin">select(foo) {
   from(bar)
   where {
      id isEqualTo 3
      or { id isEqualTo 4 }
   }
}
</code></pre></section><section><a id="Migrating_Compound_Column_and_Condition_Criteria"></a>
<h3>Migrating Compound Column and Condition Criteria</h3>
<p>In prior releases, a criterion with multiple column and conditions grouped together was written like the following:</p>

<pre class="prettyprint"><code class="language-kotlin">select(foo) {
    from(bar)
    where(id, isEqualTo(3)) {
        or(id, isEqualTo(4))
    }
}
</code></pre>
<p>These criteria should be updated by moving the first column and condition into the lambda, using infix functions,
and updating the second criterion as well:</p>

<pre class="prettyprint"><code class="language-kotlin">select(foo) {
    from(bar)
    where {
       id isEqualTo 3
       or { id isEqualTo 4 }
    }
}
</code></pre></section><section><a id="Migrating_Criteria_Using_Filter_and_Map"></a>
<h3>Migrating Criteria Using Filter and Map</h3>
<p>In prior releases, a criterion that used filter and map was written as follows:</p>

<pre class="prettyprint"><code class="language-kotlin">select(foo) {
   from(bar)
   where(firstName, isLike(&quot;fred&quot;).map { &quot;%$it%&quot; }) // add SQL wildcards
}
</code></pre>
<p>These criteria should be updated by moving the column and condition into a lambda and using the &#x201c;invoke&#x201d; operator
function:</p>

<pre class="prettyprint"><code class="language-kotlin">select(foo) {
   from(bar)
   where { firstName (isLike(&quot;fred&quot;).map { &quot;%$it%&quot; }) } // add SQL wildcards
}
</code></pre></section><section><a id="Migrating_Exists_Criteria"></a>
<h3>Migrating Exists Criteria</h3>
<p>In prior releases, a criterion that used an &#x201c;exists&#x201d; sub-query looked like this:</p>

<pre class="prettyprint"><code class="language-kotlin">select(foo) {
   from(bar)
   where(
      exists {
         select(baz) {
            from(bar)
         }
      }
   )
}
</code></pre>
<p>These criteria should be updated by moving the &#x201c;exists&#x201d; phrase into a lambda:</p>

<pre class="prettyprint"><code class="language-kotlin">select(foo) {
  from(bar)
  where {
     exists {
        select(baz) {
           from(bar)
        }
     }
  }
}
</code></pre></section><section><a id="Migrating_Not_Exists_Criteria"></a>
<h3>Migrating Not Exists Criteria</h3>
<p>In prior releases, a criterion that used a &#x201c;not exists&#x201d; sub-query looked like this:</p>

<pre class="prettyprint"><code class="language-kotlin">select(foo) {
   from(bar)
   where(
      notExists {
         select(baz) {
            from(bar)
         }
      }
   )
}
</code></pre>
<p>These criteria should be updated by moving the phrase into a lambda, and replacing &#x201c;notExists&#x201d; with a combination
of &#x201c;not&#x201d; and &#x201c;exists&#x201d;:</p>

<pre class="prettyprint"><code class="language-kotlin">select(foo) {
  from(bar)
  where {
     not {
        exists {
           select(baz) {
              from(bar)
           }
        }
     }
  }
}
</code></pre></section><section><a id="Migrating_Compound_Exists_Criteria"></a>
<h3>Migrating Compound Exists Criteria</h3>
<p>In prior releases, a criterion that used a compound &#x201c;exists&#x201d; sub-query looked like this:</p>

<pre class="prettyprint"><code class="language-kotlin">select(foo) {
   from(bar)
   where(
      exists {
         select(baz) {
            from(bar)
         }
      }
   ) {
       or(id, isEqualTo(3))
   }
}
</code></pre>
<p>These criteria should be updated by moving the &#x201c;exists&#x201d; phrase into the lambda and updating any other criteria:</p>

<pre class="prettyprint"><code class="language-kotlin">select(foo) {
  from(bar)
  where {
     exists {
        select(baz) {
           from(bar)
        }
     }
     or { id isEqualTo 3 }
  }
}
</code></pre></section></section></section>        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Â©      2016â€“2025
<a href="https://www.mybatis.org/">MyBatis.org</a>
</p>
        </div>
      </div>
    </footer>
  </body>
</html>
