<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 1.11.1 from src/site/markdown/docs/mybatis3.md at 07 October 2022
 | Rendered using Apache Maven Fluido Skin 1.11.1
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.11.1" />
    <title>MyBatis Dynamic SQL &#x2013; Specialized Support for MyBatis3</title>
    <link rel="stylesheet" href="../css/apache-maven-fluido-1.11.1.min.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
    <script src="../js/apache-maven-fluido-1.11.1.min.js"></script>
  </head>
  <body class="topBarDisabled">
    <div class="container-fluid">
      <header>
        <div id="banner">
          <div class="pull-left"><a href="../docs/introduction.html" id="bannerLeft"><h1>MyBatis Dynamic SQL</h1>
</a></div>
          <div class="pull-right"><a href="http://www.mybatis.org/" id="bannerRight" title="MyBatis logo"><img src="https://mybatis.org/images/mybatis-logo.png"  alt="MyBatis logo" style="" /></a></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 07 October 2022<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 1.4.1</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">User's Guide</li>
    <li><a href="../docs/introduction.html" title="Introduction"><span class="none"></span>Introduction</a></li>
    <li><a href="../docs/CHANGELOG.html" title="Change Log"><span class="none"></span>Change Log</a></li>
    <li><a href="../docs/quickStart.html" title="Quick Start"><span class="none"></span>Quick Start</a></li>
    <li><a href="../docs/exceptions.html" title="Exceptions thrown by the Library"><span class="none"></span>Exceptions thrown by the Library</a></li>
    <li><a href="../docs/configuration.html" title="Configuration of the Library"><span class="none"></span>Configuration of the Library</a></li>
    <li><a href="../docs/databaseObjects.html" title="Modeling Database Objects"><span class="none"></span>Modeling Database Objects</a></li>
    <li><a href="../docs/whereClauses.html" title="WHERE Clause Support"><span class="icon-chevron-down"></span>WHERE Clause Support</a>
     <ul class="nav nav-list">
      <li><a href="../docs/conditions.html" title="WHERE Conditions"><span class="none"></span>WHERE Conditions</a></li>
     </ul></li>
    <li><a href="../docs/select.html" title="SELECT Statements"><span class="icon-chevron-down"></span>SELECT Statements</a>
     <ul class="nav nav-list">
      <li><a href="../docs/complexQueries.html" title="Complex Queries"><span class="none"></span>Complex Queries</a></li>
     </ul></li>
    <li><a href="../docs/delete.html" title="DELETE Statements"><span class="none"></span>DELETE Statements</a></li>
    <li><a href="../docs/insert.html" title="INSERT Statements"><span class="none"></span>INSERT Statements</a></li>
    <li><a href="../docs/update.html" title="UPDATE Statements"><span class="none"></span>UPDATE Statements</a></li>
    <li><a href="../docs/subQueries.html" title="SubQuery Support"><span class="none"></span>SubQuery Support</a></li>
    <li><a href="../docs/functions.html" title="Database Functions"><span class="none"></span>Database Functions</a></li>
    <li class="active"><a><span class="none"></span>MyBatis3 Support</a></li>
    <li><a href="../docs/spring.html" title="Spring Support"><span class="none"></span>Spring Support</a></li>
    <li><a href="../docs/springBatch.html" title="Spring Batch Support"><span class="none"></span>Spring Batch Support</a></li>
    <li><a href="../docs/kotlinOverview.html" title="Kotlin Support"><span class="icon-chevron-right"></span>Kotlin Support</a></li>
    <li><a href="../docs/howItWorks.html" title="How it Works"><span class="none"></span>How it Works</a></li>
    <li><a href="../docs/extending.html" title="Extending the Library"><span class="none"></span>Extending the Library</a></li>
    <li><a href="../docs/codingStandards.html" title="Coding Standards"><span class="none"></span>Coding Standards</a></li>
    <li><a href="../docs/motivation.html" title="Motivation"><span class="none"></span>Motivation</a></li>
   <li class="nav-header">Project Documentation</li>
    <li><a href="../project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="../project-reports.html" title="Project Reports"><span class="icon-chevron-right"></span>Project Reports</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="../images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn"  class="span10" >
<h1>Specialized Support for MyBatis3</h1>
<p>Most of the examples shown on this site are for usage with MyBatis3 - even though the library does support other SQL
runtimes like Spring JDBC templates. In addition to the examples shown elsewhere, the library has additional specialized
support for MyBatis3 beyond what is shown in the other examples. This support mainly exists to support MyBatis Generator
and the code generated by that tool. Even without MyBatis Generator, the techniques shown on this page may prove useful.</p>
<p>The goal of this support is to reduce the amount of boilerplate code needed for a typical CRUD mapper. For example, this
support allows you to create a reusable SELECT method where the user only needs to specify a WHERE clause.</p>
<p>With version 1.1.3, specialized interfaces and utilities were added that can further simplify client code. This support
enables the creation of methods that have similar functionality to methods generated in previous versions of MyBatis
generator like countByExample, deleteByExample, and selectByExample. We no longer use the &#x201c;by example&#x201d; terms for these
methods as this library has eliminated the Example class that was generated by prior versions of MyBatis Generator.</p><section>
<h2><a name="Common_Mapper_Support"></a>Common Mapper Support</h2>
<p>The library includes several common mappers for MyBatis that can be injected into a MyBatis configuration as-is, or can be
extended. These mappers can be used to eliminate repetitive boilerplate code for several operations - namely count queries,
deletes, inserts, and updates. In addition, there is a common select mapper that can be used to avoid writing custom
result maps for every query. The common select mapper provides a row mapper function that is very similar to Spring
JDBC template.</p><section>
<h3><a name="Common_Count.2C_Delete.2C_Insert.2C_and_Update_Mappers"></a>Common Count, Delete, Insert, and Update Mappers</h3>
<p>These mappers provide utility functions that execute simple queries. They can be used as-as, or can be extended. They
provide methods as follows:</p>
<table border="0" class="table table-striped">
<thead>

<tr class="a">
<th>Mapper</th>
<th>Methods(s)</th></tr>
</thead><tbody>

<tr class="b">
<td align="left"><code>org.mybatis.dynamic.sql.util.mybatis3.CommonCountMapper</code></td>
<td><code>long count(SelectStatementProvider)</code></td></tr>
<tr class="a">
<td align="left"><code>org.mybatis.dynamic.sql.util.mybatis3.CommonDeleteMapper</code></td>
<td><code>int delete(DeleteStatementProvider)</code></td></tr>
<tr class="b">
<td align="left"><code>org.mybatis.dynamic.sql.util.mybatis3.CommonInsertMapper&lt;T&gt;</code></td>
<td><code>int insert(InsertStatementProvider&lt;T&gt;)</code><br /><code>int generalInsert(GeneralInsertStatementProvider)</code><br /><code>int insertSelect(InsertSelectStatementProvider)</code><br /><code>int insertMultiple(MultiRowInsertStatementProvider&lt;T&gt;)</code></td></tr>
<tr class="a">
<td align="left"><code>org.mybatis.dynamic.sql.util.mybatis3.CommonUpdateMapper</code></td>
<td><code>int update(UpdateStatementProvider)</code></td></tr>
</tbody>
</table>
<p>These mappers, as well as the common selectmapper, can be used to create a general purpose CRUD mapper as follows:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">import org.apache.ibatis.annotations.Mapper;
import org.mybatis.dynamic.sql.util.mybatis3.CommonCountMapper;
import org.mybatis.dynamic.sql.util.mybatis3.CommonDeleteMapper;
import org.mybatis.dynamic.sql.util.mybatis3.CommonInsertMapper;
import org.mybatis.dynamic.sql.util.mybatis3.CommonSelectMapper;
import org.mybatis.dynamic.sql.util.mybatis3.CommonUpdateMapper;

@Mapper
public interface FooMapper extends CommonCountMapper, CommonDeleteMapper, CommonInsertMapper&lt;Foo&gt;, CommonSelectMapper,
        CommonUpdateMapper {
}
</code></pre></div>
<p>This mapper can be extended with default methods as shown below.</p></section><section>
<h3><a name="Common_Select_Mapper"></a>Common Select Mapper</h3>
<p>MyBatis is very good at mapping result sets to objects - this is one of its primary differentiators. MyBatis also requires
that you predefine the mappings for every possibility. This presents a challenge if you want very dynamic column lists
in a query. This library provides a generalized MyBatis mapper that can assist with that problem.</p>
<p>The general mapper is <code>org.mybatis.dynamic.sql.util.mybatis3.CommonSelectMapper</code>. This mapper can be injected into a
MyBatis configuration as is, or it can be extended by an existing mapper.</p>
<p>The mapper contains three types of methods:</p>
<ol style="list-style-type: decimal">

<li>The <code>selectOneMappedRow</code> and <code>selectManyMappedRows</code> methods allow you to use select statements with
any number of columns. MyBatis will process the rows and return a Map of values, or a List of Maps for multiple rows.</li>
<li>The <code>selectOne</code> and <code>selectMany</code> methods also allow you to use select statements with any number of columns. These methods
also allow you to specify a function that will transform a Map of row values into a specific object.</li>
<li>The other methods are for result sets with a single column. There are functions for many
data types (Integer, Long, String, etc.) There are also functions that return a single value, and Optional value,
or a List of values.</li>
</ol>
<p>An example of using the mapped row methods follows:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">package foo.service;
import static org.mybatis.dynamic.sql.SqlBuilder.*;

import java.util.List;
import java.util.Map;
import org.mybatis.dynamic.sql.render.RenderingStrategies;
import org.mybatis.dynamic.sql.select.render.SelectStatementProvider;
import org.mybatis.dynamic.sql.util.mybatis3.CommonSelectMapper;

public class MyService {
    public List&lt;Map&lt;String,Object&gt;&gt; generalSearch() {
        CommonSelectMapper mapper = getGeneralMapper(); // not shown

        SelectStatementProvider selectStatement = select(id, description)
            .from(foo)
            .where(description. isLike(&quot;%bar%&quot;))
            .build()
            .render(RenderingStrategies.MYBATIS3);
        return  mapper.selectManyMappedRows(selectStatement);
    }
}
</code></pre></div>
<p>As you can see, the method returns a List of Maps containing the row values. The Map key will be the column name as
returned from the database (typically in upper case), and the column value as returned from the <code>ResultSet.getObject()</code>.
See your JDBC driver's documentation for details about how SQL types are mapped to Java types to determine the data type
for your specific database.</p>
<p>This method works well, but usually it is better to marshal the result set into actual objects. This can be accomplished
as follows:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">package foo.service;
import static org.mybatis.dynamic.sql.SqlBuilder.*;

import java.util.List;
import org.mybatis.dynamic.sql.render.RenderingStrategies;
import org.mybatis.dynamic.sql.select.render.SelectStatementProvider;
import org.mybatis.dynamic.sql.util.mybatis3.CommonSelectMapper;

public class MyService {
    public List&lt;TableCode&gt; generalSearch() {
        CommonSelectMapper mapper = getGeneralMapper(); // not shown

        SelectStatementProvider selectStatement = select(id, description)
            .from(foo)
            .where(description. isLike(&quot;%bar%&quot;))
            .build()
            .render(RenderingStrategies.MYBATIS3);
        return  mapper.selectMany(selectStatement, m -&gt; {
            TableCode tc = new TableCode();
            tc.setId((Integer) m.get(&quot;ID&quot;));
            tc.setDescription((String) m.get(&quot;DESCRIPTION&quot;));
            return tc;
        });
    }
}
</code></pre></div>
<p>With this method you can centralize all the database specific operations in a single method.</p>
<p>If you only have a single column in the result set, the general mapper provides methods to retrieve the value directly.
For example:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">package foo.service;
import static org.mybatis.dynamic.sql.SqlBuilder.*;

import org.mybatis.dynamic.sql.render.RenderingStrategies;
import org.mybatis.dynamic.sql.select.render.SelectStatementProvider;
import org.mybatis.dynamic.sql.util.mybatis3.CommonSelectMapper;

public class MyService {
    public Long getAverageAge() {
        CommonSelectMapper mapper = getGeneralMapper(); // not shown

        SelectStatementProvider selectStatement = select(avg(age))
            .from(foo)
            .where(description. isLike(&quot;%bar%&quot;))
            .build()
            .render(RenderingStrategies.MYBATIS3);
        return  mapper.selectOneLong(selectStatement);
    }
}
</code></pre></div></section></section><section>
<h2><a name="Count_Method_Support"></a>Count Method Support</h2>
<p>The goal of count method support is to enable the creation of methods that execute a count query allowing a user to
specify a where clause at runtime, but abstracting away all other details.</p>
<p>To use this support, we envision creating several methods on a MyBatis mapper interface. The first method is the
standard MyBatis Dynamic SQL method that will execute a select:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">@SelectProvider(type=SqlProviderAdapter.class, method=&quot;select&quot;)
long count(SelectStatementProvider selectStatement);
</code></pre></div>
<p>This is a standard method for MyBatis Dynamic SQL that executes a query and returns a <code>long</code>. The other methods will reuse
this method and supply everything needed to build the select statement except the where clause. In lieu of writing this method,
you could extend <code>org.mybatis.dynamic.sql.util.mybatis3.CommonCountMapper</code> instead. There are several variants
of count queries that may be useful:</p>
<ol style="list-style-type: decimal">

<li><code>count(*)</code> - counts the number of rows that match a where clause</li>
<li><code>count(column)</code> - counts the number of non-null column values that match a where clause</li>
<li><code>count(distinct column)</code> - counts the number of unique column values that match a where clause</li>
</ol>
<p>Corresponding mapper methods are as follows:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">default long count(CountDSLCompleter completer) {  // count(*)
    return MyBatis3Utils.countFrom(this::count, person, completer);
}

default long count(BasicColumn column, CountDSLCompleter completer) { // count(column)
    return MyBatis3Utils.count(this::count, column, person, completer);
}

default long countDistinct(BasicColumn column, CountDSLCompleter completer) { // count(distinct column)
    return MyBatis3Utils.countDistinct(this::count, column, person, completer);
}
</code></pre></div>
<p>These methods show the use of <code>CountDSLCompleter</code> which is a specialization of a <code>java.util.Function</code> that will allow
a user to supply a where clause. Clients can use the method as follows:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">long rows = mapper.count(c -&gt;
        c.where(occupation, isNull()));
</code></pre></div>
<p>There is a utility method that can be used to count all rows in a table:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">long rows = mapper.count(CountDSLCompleter.allRows());
</code></pre></div></section><section>
<h2><a name="Delete_Method_Support"></a>Delete Method Support</h2>
<p>The goal of delete method support is to enable the creation of methods that execute a delete statement allowing a user
to specify a where clause at runtime, but abstracting away all other details.</p>
<p>To use this support, we envision creating two methods on a MyBatis mapper interface. The first method is the standard
MyBatis Dynamic SQL method that will execute a delete:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">@DeleteProvider(type=SqlProviderAdapter.class, method=&quot;delete&quot;)
int delete(DeleteStatementProvider deleteStatement);
</code></pre></div>
<p>This is a standard method for MyBatis Dynamic SQL that executes a delete and returns an <code>int</code> - the number of rows deleted.
In lieu of writing this method, you could extend <code>org.mybatis.dynamic.sql.util.mybatis3.CommonDeleteMapper</code> instead.
The second method will reuse this method and supply everything needed to build the delete statement except the where clause:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">default int delete(DeleteDSLCompleter completer) {
    return MyBatis3Utils.deleteFrom(this::delete, person, completer);
}
</code></pre></div>
<p>This method shows the use of <code>DeleteDSLCompleter</code> which is a specialization of a <code>java.util.Function</code> that will allow a
user to supply a where clause. Clients can use the method as follows:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">int rows = mapper.delete(c -&gt;
        c.where(occupation, isNull()));
</code></pre></div>
<p>There is a utility method that can be used to delete all rows in a table:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">int rows = mapper.delete(DeleteDSLCompleter.allRows());
</code></pre></div></section><section>
<h2><a name="Insert_Method_Support"></a>Insert Method Support</h2>
<p>The goal of insert method support is to remove some of the boilerplate code from insert methods in a mapper interfaces.</p>
<p>To use this support, we envision creating several methods on a MyBatis mapper interface. The first methods are the
standard MyBatis methods that will execute an insert:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">@InsertProvider(type=SqlProviderAdapter.class, method=&quot;insert&quot;)
int insert(InsertStatementProvider&lt;PersonRecord&gt; insertStatement);

@InsertProvider(type=SqlProviderAdapter.class, method=&quot;generalInsert&quot;)
int generalInsert(GeneralInsertStatementProvider insertStatement);

@InsertProvider(type=SqlProviderAdapter.class, method=&quot;insertMultiple&quot;)
int insertMultiple(MultiRowInsertStatementProvider&lt;PersonRecord&gt; insertStatement);
</code></pre></div>
<p>These methods are standard methods for MyBatis Dynamic SQL. They execute a single row insert, a general insert, and a
multiple row insert. In lieu of writing these methods, you could extend
<code>org.mybatis.dynamic.sql.util.mybatis3.CommonInsertMapper</code> instead.</p>
<p>These methods can be used to implement simplified insert methods:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">default int insert(UnaryOperator&lt;GeneralInsertDSL&gt; completer) {
    return MyBatis3Utils.insert(this::generalInsert, person, completer);
}

default int insert(PersonRecord record) {
    return MyBatis3Utils.insert(this::insert, record, person, c -&gt; 
        c.map(id).toProperty(&quot;id&quot;)
        .map(firstName).toProperty(&quot;firstName&quot;)
        .map(lastName).toProperty(&quot;lastName&quot;)
        .map(birthDate).toProperty(&quot;birthDate&quot;)
        .map(employed).toProperty(&quot;employed&quot;)
        .map(occupation).toProperty(&quot;occupation&quot;)
        .map(addressId).toProperty(&quot;addressId&quot;)
    );
}

default int insertMultiple(PersonRecord...records) {
    return insertMultiple(Arrays.asList(records));
}

default int insertMultiple(Collection&lt;PersonRecord&gt; records) {
    return MyBatis3Utils.insertMultiple(this::insertMultiple, records, person, c -&gt;
        c.map(id).toProperty(&quot;id&quot;)
        .map(firstName).toProperty(&quot;firstName&quot;)
        .map(lastName).toProperty(&quot;lastName&quot;)
        .map(birthDate).toProperty(&quot;birthDate&quot;)
        .map(employed).toProperty(&quot;employed&quot;)
        .map(occupation).toProperty(&quot;occupation&quot;)
        .map(addressId).toProperty(&quot;addressId&quot;)
    );
}
</code></pre></div>
<p>The first insert method is a general insert and can be used to create arbitrary inserts with different combinations of
columns specified. The other methods have the insert statements mapped to a POJO &#x201c;record&#x201d; class that holds values for
the insert statement.</p></section><section>
<h2><a name="Select_Method_Support"></a>Select Method Support</h2>
<p>The goal of select method support is to enable the creation of methods that execute a select statement allowing a user
to specify a where clause and/or order by clause at runtime, but abstracting away all other details.</p>
<p>To use this support, we envision creating several methods on a MyBatis mapper interface. The first two methods are the
standard MyBatis Dynamic SQL method that will execute a select:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">@SelectProvider(type=SqlProviderAdapter.class, method=&quot;select&quot;)
@Results(id=&quot;PersonResult&quot;, value= {
        @Result(column=&quot;A_ID&quot;, property=&quot;id&quot;, jdbcType=JdbcType.INTEGER, id=true),
        @Result(column=&quot;first_name&quot;, property=&quot;firstName&quot;, jdbcType=JdbcType.VARCHAR),
        @Result(column=&quot;last_name&quot;, property=&quot;lastName&quot;, jdbcType=JdbcType.VARCHAR),
        @Result(column=&quot;birth_date&quot;, property=&quot;birthDate&quot;, jdbcType=JdbcType.DATE),
        @Result(column=&quot;employed&quot;, property=&quot;employed&quot;, jdbcType=JdbcType.VARCHAR),
        @Result(column=&quot;occupation&quot;, property=&quot;occupation&quot;, jdbcType=JdbcType.VARCHAR)
})
List&lt;PersonRecord&gt; selectMany(SelectStatementProvider selectStatement);
    
@SelectProvider(type=SqlProviderAdapter.class, method=&quot;select&quot;)
@ResultMap(&quot;PersonResult&quot;)
Optional&lt;PersonRecord&gt; selectOne(SelectStatementProvider selectStatement);
</code></pre></div>
<p>These two methods are standard methods for MyBatis Dynamic SQL. They execute a select and return either a list of
records, or a single record.</p>
<p>We also envision creating a static field for a reusable list of columns for a select statement:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">BasicColumn[] selectList =
    BasicColumn.columnList(id.as(&quot;A_ID&quot;), firstName, lastName, birthDate, employed, occupation, addressId);
</code></pre></div>
<p>The <code>selectOne</code> method can be used to implement a generalized select one method:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">default Optional&lt;PersonRecord&gt; selectOne(SelectDSLCompleter completer) {
    return MyBatis3Utils.selectOne(this::selectOne, selectList, person, completer);
}
</code></pre></div>
<p>This method shows the use of <code>SelectDSLCompleter</code> which is a specialization of a <code>java.util.Function</code> that will allow a
user to supply a where clause.</p>
<p>The general <code>selectOne</code> method can be used to implement a <code>selectByPrimaryKey</code> method:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">default Optional&lt;PersonRecord&gt; selectByPrimaryKey(Integer id_) {
    return selectOne(c -&gt;
        c.where(id, isEqualTo(id_))
    );
}
</code></pre></div>
<p>The <code>selectMany</code> method can be used to implement generalized select methods where a user can specify a where clause
and/or an order by clause. Typically, we recommend two of these methods - for select, and select distinct:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">default List&lt;PersonRecord&gt; select(SelectDSLCompleter completer) {
    return MyBatis3Utils.selectList(this::selectMany, selectList, person, completer);
}
    
default List&lt;PersonRecord&gt; selectDistinct(SelectDSLCompleter completer) {
    return MyBatis3Utils.selectDistinct(this::selectMany, selectList, person, completer);
}
</code></pre></div>
<p>These methods show the use of <code>SelectDSLCompleter</code> which is a specialization of a <code>java.util.Function</code> that will
allow a user to supply a where clause and/or an order by clause.</p>
<p>Clients can use the methods as follows:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">List&lt;PersonRecord&gt; rows = mapper.select(c -&gt;
        c.where(id, isEqualTo(1))
        .or(occupation, isNull()));
</code></pre></div>
<p>There are utility methods that will select all rows in a table:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">List&lt;PersonRecord&gt; rows =
    mapper.select(SelectDSLCompleter.allRows());
</code></pre></div>
<p>The following query will select all rows in a specified order:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">List&lt;PersonRecord&gt; rows =
    mapper.select(SelectDSLCompleter.allRowsOrderedBy(lastName, firstName));
</code></pre></div></section><section>
<h2><a name="Update_Method_Support"></a>Update Method Support</h2>
<p>The goal of update method support is to enable the creation of methods that execute an update statement allowing a user
to specify values to set and a where clause at runtime, but abstracting away all other details.</p>
<p>To use this support, we envision creating several methods on a MyBatis mapper interface. The first method is a standard
MyBatis Dynamic SQL method that will execute a update:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">@UpdateProvider(type=SqlProviderAdapter.class, method=&quot;update&quot;)
int update(UpdateStatementProvider updateStatement);
</code></pre></div>
<p>This is a standard method for MyBatis Dynamic SQL that executes a query and returns an <code>int</code> - the number of rows updated.
In lieu of writing this method, you could extend <code>org.mybatis.dynamic.sql.util.mybatis3.CommonUpdateMapper</code> instead.
The second method will reuse this method and supply everything needed to build the update statement except the values
and the where clause:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">default int update(UpdateDSLCompleter completer) {
    return MyBatis3Utils.update(this::update, person, completer);
}
</code></pre></div>
<p>This method shows the use of <code>UpdateDSLCompleter</code> which is a specialization of a <code>java.util.Function</code> that will allow a
user to supply values and a where clause. Clients can use the method as follows:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">int rows = mapper.update(c -&gt;
    c.set(occupation).equalTo(&quot;Programmer&quot;)
    .where(id, isEqualTo(100)));
</code></pre></div>
<p>All rows in a table can be updated by simply omitting the where clause:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">int rows = mapper.update(c -&gt;
    c.set(occupation).equalTo(&quot;Programmer&quot;));
</code></pre></div>
<p>It is also possible to write a utility method that will set values. For example:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">static UpdateDSL&lt;UpdateModel&gt; updateSelectiveColumns(PersonRecord row,
        UpdateDSL&lt;UpdateModel&gt; dsl) {
    return dsl.set(id).equalToWhenPresent(row::getId)
            .set(firstName).equalToWhenPresent(row::getFirstName)
            .set(lastName).equalToWhenPresent(row::getLastName)
            .set(birthDate).equalToWhenPresent(row::getBirthDate)
            .set(employed).equalToWhenPresent(row::getEmployed)
            .set(occupation).equalToWhenPresent(row::getOccupation);
}
</code></pre></div>
<p>This method will selectively set values if corresponding fields in a record are non null. This method can be used as follows:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">rows = mapper.update(h -&gt;
    updateSelectiveColumns(updateRecord, h)
    .where(id, isEqualTo(100)));
</code></pre></div></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>&#169;      2016&#x2013;2022
<a href="https://www.mybatis.org/">MyBatis.org</a>
</p>
        </div>
      </div>
    </footer>
<script>
	if(anchors) {
	  anchors.add();
	}
</script>
  </body>
</html>
