<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.9.2 from src/site/markdown/docs/databaseObjects.md at 18 December 2021
 | Rendered using Apache Maven Fluido Skin 1.8
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.9.2" />
    <title>MyBatis Dynamic SQL &#x2013; Database Object Representation</title>
    <link rel="stylesheet" href="../css/apache-maven-fluido-1.8.min.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
    <script src="../js/apache-maven-fluido-1.8.min.js"></script>
  </head>
  <body class="topBarDisabled">
    <div class="container-fluid">
      <header>
        <div id="banner">
          <div class="pull-left"><a href="../docs/introduction.html" id="bannerLeft"><h2>MyBatis Dynamic SQL</h2>
</a></div>
          <div class="pull-right"><a href="http://www.mybatis.org/" id="bannerRight" title="MyBatis logo"><img src="http://mybatis.github.io/images/mybatis-logo.png"  alt="MyBatis logo"/></a></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 18 December 2021<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 1.3.1</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">User's Guide</li>
    <li><a href="../docs/introduction.html" title="Introduction"><span class="none"></span>Introduction</a></li>
    <li><a href="../docs/CHANGELOG.html" title="Change Log"><span class="none"></span>Change Log</a></li>
    <li><a href="../docs/quickStart.html" title="Quick Start"><span class="none"></span>Quick Start</a></li>
    <li class="active"><a href="#"><span class="none"></span>Modeling Database Objects</a></li>
    <li><a href="../docs/whereClauses.html" title="WHERE Clause Support"><span class="icon-chevron-down"></span>WHERE Clause Support</a>
     <ul class="nav nav-list">
      <li><a href="../docs/conditions.html" title="WHERE Conditions"><span class="none"></span>WHERE Conditions</a></li>
     </ul></li>
    <li><a href="../docs/select.html" title="SELECT Statements"><span class="icon-chevron-down"></span>SELECT Statements</a>
     <ul class="nav nav-list">
      <li><a href="../docs/complexQueries.html" title="Complex Queries"><span class="none"></span>Complex Queries</a></li>
     </ul></li>
    <li><a href="../docs/delete.html" title="DELETE Statements"><span class="none"></span>DELETE Statements</a></li>
    <li><a href="../docs/insert.html" title="INSERT Statements"><span class="none"></span>INSERT Statements</a></li>
    <li><a href="../docs/update.html" title="UPDATE Statements"><span class="none"></span>UPDATE Statements</a></li>
    <li><a href="../docs/subQueries.html" title="SubQuery Support"><span class="none"></span>SubQuery Support</a></li>
    <li><a href="../docs/functions.html" title="Database Functions"><span class="none"></span>Database Functions</a></li>
    <li><a href="../docs/mybatis3.html" title="MyBatis3 Support"><span class="none"></span>MyBatis3 Support</a></li>
    <li><a href="../docs/spring.html" title="Spring Support"><span class="none"></span>Spring Support</a></li>
    <li><a href="../docs/springBatch.html" title="Spring Batch Support"><span class="none"></span>Spring Batch Support</a></li>
    <li><a href="../docs/kotlinOverview.html" title="Kotlin Support"><span class="icon-chevron-right"></span>Kotlin Support</a></li>
    <li><a href="../docs/howItWorks.html" title="How it Works"><span class="none"></span>How it Works</a></li>
    <li><a href="../docs/extending.html" title="Extending the Library"><span class="none"></span>Extending the Library</a></li>
    <li><a href="../docs/codingStandards.html" title="Coding Standards"><span class="none"></span>Coding Standards</a></li>
    <li><a href="../docs/motivation.html" title="Motivation"><span class="none"></span>Motivation</a></li>
   <li class="nav-header">Project Documentation</li>
    <li><a href="../project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="../project-reports.html" title="Project Reports"><span class="icon-chevron-right"></span>Project Reports</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <hr />
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="../images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn"  class="span10" >
<h1>Database Object Representation</h1>
<p>MyBatis Dynamic SQL works with Java objects that represent relational tables or views.</p><section>
<h2><a name="Table_or_View_Representation"></a>Table or View Representation</h2>
<p>The class <code>org.mybatis.dynamic.sql.SqlTable</code> is used to represent a table or view in a database. An <code>SqlTable</code> holds a name, and a collection of <code>SqlColumn</code> objects that represent the columns in a table or view.</p>
<p>A table or view name in SQL has three parts:</p>
<ol style="list-style-type: decimal">

<li>The catalog - which is optional and is rarely used outside of Microsoft SQL Server. If unspecified the default catalog will be used - and many databases only have one catalog</li>
<li>The schema - which is optional but is very often specified. If unspecified, the default schema will be used</li>
<li>The table name - which is required</li>
</ol>
<p>Typical examples of names are as follows:</p>
<ul>

<li><code>&quot;dbo..bar&quot;</code> - a name with a catalog (dbo) and a table name (bar). This is typical for SQL Server</li>
<li><code>&quot;foo.bar&quot;</code> - a name with a schema (foo) and a table name (bar). This is typical in many databases when you want to access tables that are not in the default schema</li>
<li><code>&quot;bar&quot;</code> - a name with just a table name (bar). This will access a table or view in the default catalog and schema for a connection</li>
</ul>
<p>In MyBatis Dynamic SQL, the table or view name can be specified in different ways:</p>
<ol style="list-style-type: decimal">

<li>The name can be a constant String</li>
<li>The name can be calculated at runtime based on a catalog and/or schema supplier functions and a constant table name</li>
<li>The name can be calculated at runtime with a name supplier function</li>
</ol><section>
<h3><a name="Constant_Names"></a>Constant Names</h3>
<p>Constant names are used when you use the <code>SqlTable</code> constructor with a single String argument. For example:</p>

<div class="source">
<div class="source"><pre class="prettyprint">public class MyTable extends SqlTable {
    public MyTable() {
        super(&quot;MyTable&quot;);
    }
}
</pre></div></div>

<p>Or</p>

<div class="source">
<div class="source"><pre class="prettyprint">public class MyTable extends SqlTable {
    public MyTable() {
        super(&quot;MySchema.MyTable&quot;);
    }
}
</pre></div></div>
</section><section>
<h3><a name="Dynamic_Catalog_and.2For_Schema_Names"></a>Dynamic Catalog and/or Schema Names</h3>
<p>MyBatis Dynamic SQL allows you to dynamically specify a catalog and/or schema. This is useful for applications where the schema may change for different users or environments, or if you are using different schemas to shard the database. Dynamic names are used when you use a <code>SqlTable</code> constructor that accepts one or more <code>java.util.function.Supplier</code> arguments.</p>
<p>For example, suppose you wanted to change the schema based on the value of a system property. You could write a class like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">public class SchemaSupplier {
    public static final String schema_property = &quot;schemaToUse&quot;;

    public static Optional&lt;String&gt; schemaPropertyReader() {
        return Optional.ofNullable(System.getProperty(schema_property));
    }
}
</pre></div></div>

<p>This class has a static method <code>schemaPropertyReader</code> that will return an <code>Optional&lt;String&gt;</code> containing the value of a system property. You could then reference this method in the constructor of the <code>SqlTable</code> like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">public static final class User extends SqlTable {
    public User() {
        super(SchemaSupplier::schemaPropertyReader, &quot;User&quot;);
    }
}
</pre></div></div>

<p>Whenever the table is referenced for rendering SQL, the name will be calculated based on the current value of the system property.</p>
<p>There are two constructors that can be used for dynamic names:</p>
<ol style="list-style-type: decimal">

<li>A constructor that accepts <code>Supplier&lt;Optional&lt;String&gt;&gt;</code> for the schema, and <code>String</code> for the name. This constructor assumes that the catalog is always empty or not used</li>
<li>A constructor that accepts <code>Supplier&lt;Optional&lt;String&gt;&gt;</code> for the catalog, <code>Supplier&lt;Optional&lt;String&gt;&gt;</code> for the schema, and <code>String</code> for the name</li>
</ol>
<p>If you are using Microsoft SQL Server and want to use a dynamic catalog name and ignore the schema, then you should use the second constructor like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">public static final class User extends SqlTable {
    public User() {
        super(CatalogSupplier::catalogPropertyReader, Optional::empty, &quot;User&quot;);
    }
}
</pre></div></div>

<p>The following table shows how the name is calculated in all combinations of suppliers:</p>
<table border="0" class="table table-striped">
<thead>

<tr class="a">
<th>Catalog Supplier Value </th>
<th> Schema Supplier Value </th>
<th> Name </th>
<th> Fully Qualified Name</th></tr>
</thead><tbody>

<tr class="b">
<td>&#x201c;MyCatalog&#x201d; </td>
<td> &#x201c;MySchema&#x201d; </td>
<td> &#x201c;MyTable&#x201d; </td>
<td> &#x201c;MyCatalog.MySchema.MyTable&#x201d;</td></tr>
<tr class="a">
<td>&lt;empty&gt; </td>
<td> &#x201c;MySchema&#x201d; </td>
<td> &#x201c;MyTable&#x201d; </td>
<td> &#x201c;MySchema.MyTable&#x201d;</td></tr>
<tr class="b">
<td>&#x201c;MyCatalog&#x201d; </td>
<td> &lt;empty&gt; </td>
<td> &#x201c;MyTable&#x201d; </td>
<td> &#x201c;MyCatalog..MyTable&#x201d;</td></tr>
<tr class="a">
<td>&lt;empty&gt; </td>
<td> &lt;empty&gt; </td>
<td> &#x201c;MyTable&#x201d; </td>
<td> &#x201c;MyTable&#x201d;</td></tr>
</tbody>
</table></section><section>
<h3><a name="Fully_Dynamic_Names"></a>Fully Dynamic Names</h3>
<p>MyBatis Dynamic SQL allows you to dynamically specify a full table name. This is useful for applications where the database is sharded with different tables representing different shards of the whole. Dynamic names are used when you use a <code>SqlTable</code> constructor that accepts a single <code>java.util.function.Supplier</code> argument.</p>
<p>For example, suppose you wanted to change the name based on the value of a system property. You could write a class like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">public class NameSupplier {
    public static final String name_property = &quot;nameToUse&quot;;

    public static String namePropertyReader() {
        return System.getProperty(name_property);
    }
}
</pre></div></div>

<p>This class has a static method <code>namePropertyReader</code> that will return an <code>String</code> containing the value of a system property. You could then reference this method in the constructor of the <code>SqlTable</code> like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">public static final class User extends SqlTable {
    public User() {
        super(NameSupplier::namePropertyReader);
    }
}
</pre></div></div>

<p>Whenever the table is referenced for rendering SQL, the name will be calculated based on the current value of the system property.</p></section></section><section>
<h2><a name="Aliased_Tables"></a>Aliased Tables</h2>
<p>In join queries, it is usually a good practice to specify table aliases. The <code>select</code> statement includes support for specifying table aliases in each query in a way that looks like natural SQL. For example:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    SelectStatementProvider selectStatement = select(orderMaster.orderId, orderDate, orderLine.lineNumber, itemMaster.description, orderLine.quantity)
            .from(orderMaster, &quot;om&quot;)
            .join(orderLine, &quot;ol&quot;).on(orderMaster.orderId, equalTo(orderLine.orderId))
            .join(itemMaster, &quot;im&quot;).on(orderLine.itemId, equalTo(itemMaster.itemId))
            .where(orderMaster.orderId, isEqualTo(2))
            .build()
            .render(RenderingStrategies.MYBATIS3);
</pre></div></div>

<p>In a query like this, the library will automatically append the table alias to the column name when the query is rendered. Internally, the alias for a column is determined by looking up the associated table in a HashMap maintained within the query model. If you do not specify a table alias, the library will automatically append the table name in join queries.</p>
<p>Unfortunately, this strategy fails for self-joins. It can also get confusing when there are sub-queries. Imagine a query like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    SelectStatementProvider selectStatement = select(user.userId, user.userName, user.parentId)
            .from(user, &quot;u1&quot;)
            .join(user, &quot;u2&quot;).on(user.userId, equalTo(user.parentId))
            .where(user.userId, isEqualTo(4))
            .build()
            .render(RenderingStrategies.MYBATIS3);
</pre></div></div>

<p>In this query it is not clear which instance of the <code>user</code> table is used for each column, and there will only be entry in the HashMap for the <code>user</code> table - so only one of the aliases specified in the select statement will be in effect. There are two ways to deal with this problem.</p>
<p>The first is to simply create another instance of the User SqlTable object. With this method it is very clear which column belongs to which instance of the table and the library can easily calculate aliases:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    User user1 = new User();
    User user2 = new User();
    SelectStatementProvider selectStatement = select(user1.userId, user1.userName, user1.parentId)
            .from(user1, &quot;u1&quot;)
            .join(user2, &quot;u2&quot;).on(user1.userId, equalTo(user2.parentId))
            .where(user2.userId, isEqualTo(4))
            .build()
            .render(RenderingStrategies.MYBATIS3);
</pre></div></div>

<p>Starting with version 1.3.1, there is new method where the alias can be specified in the table object itself. This allows you to move the aliases out of the <code>select</code> statement.</p>

<div class="source">
<div class="source"><pre class="prettyprint">    User user1 = user.withAlias(&quot;u1&quot;);
    User user2 = user.withAlias(&quot;u2&quot;);

    SelectStatementProvider selectStatement = select(user1.userId, user1.userName, user1.parentId)
            .from(user1)
            .join(user2).on(user1.userId, equalTo(user2.parentId))
            .where(user2.userId, isEqualTo(4))
            .build()
            .render(RenderingStrategies.MYBATIS3);
</pre></div></div>

<p>To enable this support, your table objects should extend <code>org.mybatis.dynamic.sql.AliasableSqlTable</code> rather than <code>org.mybatis.dynamic.sql.SqlTable</code> as follows:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    public static final class User extends AliasableSqlTable&lt;User&gt; {
        public final SqlColumn&lt;Integer&gt; userId = column(&quot;user_id&quot;, JDBCType.INTEGER);
        public final SqlColumn&lt;String&gt; userName = column(&quot;user_name&quot;, JDBCType.VARCHAR);
        public final SqlColumn&lt;Integer&gt; parentId = column(&quot;parent_id&quot;, JDBCType.INTEGER);

        public User() {
            super(&quot;User&quot;, User::new);
        }
    }
</pre></div></div>

<p>If you use an aliased table object, and also specify an alias in the <code>select</code> statement, the alias from the <code>select</code> statement will override the alias in the table object.</p></section><section>
<h2><a name="Column_Representation"></a>Column Representation</h2>
<p>The class <code>org.mybatis.dynamic.sql.SqlColumn</code> is used to represent a column in a table or view. An <code>SqlColumn</code> is always associated with a <code>SqlTable</code>. In its most basic form, the <code>SqlColumn</code> class holds a name and a reference to the <code>SqlTable</code> it is associated with. The table reference is required so that table aliases can be applied to columns in the rendering phase.</p>
<p>The <code>SqlColumn</code> will be rendered in SQL based on the <code>RenderingStrategy</code> applied to the SQL statement. Typically the rendering strategy generates a string that represents a parameter marker in whatever SQL engine you are using. For example, MyBatis3 parameter markers are formatted as &#x201c;#{some_attribute}&#x201d;. By default, all columns are rendered with the same strategy. The library supplies rendering strategies that are appropriate for several SQL execution engines including MyBatis3 and Spring JDBC template.</p>
<p>In some cases it is necessary to override the rendering strategy for a particular column - so the <code>SqlColumn</code> class supports specifying a rendering strategy for a column that will override the rendering strategy applied to a statement. A good example of this use case is with PostgreSQL. In that database it is required to add the string &#x201c;::jsonb&#x201d; to a prepared statement parameter marker when inserting or updating JSON fields, but not for other fields. A column based rendering strategy enables this.</p>
<p>The <code>SqlColumn</code> class has additional optional attributes that are useful for SQL rendering - especially in MyBatis3. These include:</p>
<ul>

<li>The <code>java.sql.JDBCType</code> of the column. This will be rendered into the MyBatis3 compatible parameter marker - which helps with picking type handlers and also inserting or updating null capable fields</li>
<li>A String containing a type handler - either a type handler alias or the fully qualified type of a type handler. This will be rendered into the MyBatis3 compatible parameter marker</li>
</ul>
<p>If you are not using MyBatis3, then you do not need to specify the JDBC Type or type handler as those attributes are ignored by other rendering strategies.</p>
<p>Finally, the <code>SqlColumn</code> class has methods to designate a column alias or sort order for use in different SQL statements.</p>
<p>We recommend a usage pattern for creating table and column objects that provides quite a bit of flexibility for usage. See the <a href="quickStart.html">Quick Start</a> page for a complete example.</p></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Copyright &#169;      2016&#x2013;2021<a href="https://www.mybatis.org/">MyBatis.org</a>.
.</p>
        </div>
      </div>
    </footer>
  </body>
</html>
