<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 2.0.0 from src/site/markdown/docs/select.md at 27 May 2025
 | Rendered using Apache Maven Fluido Skin 2.1.0
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 2.0.0" />
    <title>Select Statements â€“ MyBatis Dynamic SQL</title>
    <link rel="stylesheet" href="../css/apache-maven-fluido-2.1.0.min.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
    <script src="../js/apache-maven-fluido-2.1.0.min.js"></script>
  </head>
  <body>
    <div class="container-fluid container-fluid-top">
      <header>
        <div id="banner">
          <div class="pull-left"><div id="bannerLeft"><h1><a href="../docs/introduction.html">MyBatis Dynamic SQL</a></h1></div></div>
          <div class="pull-right"><div id="bannerRight"><h1><a href="http://www.mybatis.org/"><img src="https://mybatis.org/images/mybatis-logo.png" alt="MyBatis logo" /> MyBatis</a></h1></div></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 03 Jun 2024<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 2.0.0-SNAPSHOT</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">User&apos;s Guide</li>
    <li><a href="../docs/introduction.html">Introduction</a></li>
    <li><a href="../docs/CHANGELOG.html">Change Log</a></li>
    <li><a href="../docs/migratingV1toV2.html">Migrating from V1 to V2</a></li>
    <li><a href="../docs/quickStart.html">Quick Start</a></li>
    <li><a href="../docs/exceptions.html">Exceptions thrown by the Library</a></li>
    <li><a href="../docs/configuration.html">Configuration of the Library</a></li>
    <li><a href="../docs/databaseObjects.html">Modeling Database Objects</a></li>
    <li><a href="../docs/whereClauses.html"><span class="icon-chevron-down"></span>WHERE Clause Support</a>
     <ul class="nav nav-list">
      <li><a href="../docs/conditions.html">WHERE Conditions</a></li>
     </ul></li>
    <li class="active"><a><span class="icon-chevron-down"></span>SELECT Statements</a>
     <ul class="nav nav-list">
      <li><a href="../docs/caseExpressions.html">Case Expressions</a></li>
      <li><a href="../docs/complexQueries.html">Complex Queries</a></li>
     </ul></li>
    <li><a href="../docs/delete.html">DELETE Statements</a></li>
    <li><a href="../docs/insert.html">INSERT Statements</a></li>
    <li><a href="../docs/update.html">UPDATE Statements</a></li>
    <li><a href="../docs/subQueries.html">SubQuery Support</a></li>
    <li><a href="../docs/functions.html">Database Functions</a></li>
    <li><a href="../docs/mybatis3.html">MyBatis3 Support</a></li>
    <li><a href="../docs/spring.html">Spring Support</a></li>
    <li><a href="../docs/springBatch.html">Spring Batch Support</a></li>
    <li><a href="../docs/kotlinOverview.html"><span class="icon-chevron-right"></span>Kotlin Support</a></li>
    <li><a href="../docs/howItWorks.html">How it Works</a></li>
    <li><a href="../docs/extending.html">Extending the Library</a></li>
    <li><a href="../docs/codingStandards.html">Coding Standards</a></li>
    <li><a href="../docs/motivation.html">Motivation</a></li>
   <li class="nav-header">Project Documentation</li>
    <li><a href="../project-info.html"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="../project-reports.html"><span class="icon-chevron-right"></span>Project Reports</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
<a href="https://maven.apache.org/" class="builtBy" target="_blank"><img class="builtBy" alt="Built by Maven" src="../images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn" class="span10">
<section><a id="Select_Statements"></a>
<h1>Select Statements</h1>
<p>Select statements are the most complex SQL statements.  This library duplicates the syntax of the most common
select statements, but purposely does not cover every possibility.</p>
<p>In general, the following are supported:</p>
<ol style="list-style-type: decimal;">

<li>The typical parts of a select statement including SELECT, DISTINCT, FROM, JOIN, WHERE, GROUP BY, UNION,
UNION ALL, ORDER BY, HAVING</li>
<li>Tables can be aliased per select statement</li>
<li>Columns can be aliased per select statement</li>
<li>Some support for aggregates (avg, min, max, sum)</li>
<li>Joins of type INNER, LEFT OUTER, RIGHT OUTER, FULL OUTER</li>
<li>Subqueries in where clauses. For example, <code>where foo in (select foo from foos where id &lt; 36)</code></li>
<li>Select from another select. For example <code>select count(*) from (select foo from foos where id &lt; 36)</code></li>
<li>Multi-Selects. For example <code>(select * from foo order by id limit 3) union (select * from foo order by id desc limit 3)</code></li>
</ol>
<p>At this time, the library does not support the following:</p>
<ol style="list-style-type: decimal;">

<li>WITH expressions</li>
<li>INTERSECT, EXCEPT, etc.</li>
</ol>
<p>The user guide page for WHERE Clauses shows examples of many types of SELECT statements with different complexities of
the WHERE clause including support for sub-queries.  We will just show a single example here, including an ORDER BY
clause:</p>

<pre class="prettyprint"><code class="language-java">SelectStatementProvider selectStatement = select(id, animalName, bodyWeight, brainWeight)
        .from(animalData)
        .where(id, isIn(1, 5, 7))
        .and(bodyWeight, isBetween(1.0).and(3.0))
        .orderBy(id.descending(), bodyWeight)
        .build()
        .render(RenderingStrategies.MYBATIS3);

List&lt;AnimalData&gt; animals = mapper.selectMany(selectStatement);
</code></pre>
<p>The WHERE and ORDER BY clauses are optional.</p><section><a id="Joins"></a>
<h2>Joins</h2>
<p>The library supports the generation of join statements.  For example:</p>

<pre class="prettyprint"><code class="language-java">SelectStatementProvider selectStatement = select(orderMaster.orderId, orderDate, orderDetail.lineNumber, orderDetail.description, orderDetail.quantity)
        .from(orderMaster, &quot;om&quot;)
        .join(orderDetail, &quot;od&quot;).on(orderMaster.orderId, isEqualTo(orderDetail.orderId))
        .build()
        .render(RenderingStrategies.MYBATIS3);
</code></pre>
<p>Notice that you can give an alias to a table if desired. If you don't specify an alias, the full table name will be
used in the generated SQL.</p>
<p>Multiple tables can be joined in a single statement. For example:</p>

<pre class="prettyprint"><code class="language-java">SelectStatementProvider selectStatement = select(orderMaster.orderId, orderDate, orderLine.lineNumber, itemMaster.description, orderLine.quantity)
        .from(orderMaster, &quot;om&quot;)
        .join(orderLine, &quot;ol&quot;).on(orderMaster.orderId, isEqualTo(orderLine.orderId))
        .join(itemMaster, &quot;im&quot;).on(orderLine.itemId, isEqualTo(itemMaster.itemId))
        .where(orderMaster.orderId, isEqualTo(2))
        .build()
        .render(RenderingStrategies.MYBATIS3);
</code></pre>
<p>Join queries will likely require you to define a MyBatis result mapping in XML. This is the only instance where XML is
required.  This is due to the limitations of the MyBatis annotations when mapping collections.</p>
<p>The library supports four join types:</p>
<ol style="list-style-type: decimal;">

<li><code>.join(...)</code> is an INNER join</li>
<li><code>.leftJoin(...)</code> is a LEFT OUTER join</li>
<li><code>.rightJoin(...)</code> is a RIGHT OUTER join</li>
<li><code>.fullJoin(...)</code> is a FULL OUTER join</li>
</ol></section><section><a id="Union_Queries"></a>
<h2>Union Queries</h2>
<p>The library supports the generation of UNION and UNION ALL queries. For example:</p>

<pre class="prettyprint"><code class="language-java">SelectStatementProvider selectStatement = select(id, animalName, bodyWeight, brainWeight)
        .from(animalData)
        .union()
        .selectDistinct(id, animalName, bodyWeight, brainWeight)
        .from(animalData)
        .orderBy(id)
        .build()
        .render(RenderingStrategies.MYBATIS3);
</code></pre>
<p>Any number of SELECT statements can be added to a UNION query. Only one ORDER BY phrase is allowed.</p>
<p>With this type of union query, the &#x201c;order by&#x201d; and paging clauses are applied to the query as a whole. If
you need to apply &#x201c;order by&#x201d; or paging clauses to the nested queries, use a multi-select query as shown
below.</p></section><section><a id="Multi-Select_Queries"></a>
<h2>Multi-Select Queries</h2>
<p>Multi-select queries are a special case of union select statements. The difference is that &#x201c;order by&#x201d; and
paging clauses can be applied to the merged queries. For example:</p>

<pre class="prettyprint"><code class="language-java">SelectStatementProvider selectStatement = multiSelect(
        select(id, animalName, bodyWeight, brainWeight)
                .from(animalData)
                .orderBy(id)
                .limit(2)
        ).union(
                selectDistinct(id, animalName, bodyWeight, brainWeight)
                .from(animalData)
                .orderBy(id.descending())
                .limit(3)
        )
        .build()
        .render(RenderingStrategies.MYBATIS3);
</code></pre></section><section><a id="MyBatis_Mapper_for_Select_Statements"></a>
<h2>MyBatis Mapper for Select Statements</h2>
<p>The SelectStatementProvider object can be used as a parameter to a MyBatis mapper method directly. If you
are using an annotated mapper, the select method should look like this (note that we recommend coding a &#x201c;selectMany&#x201d;
and a &#x201c;selectOne&#x201d; method with a shared result mapping):</p>

<pre class="prettyprint"><code class="language-java">import org.apache.ibatis.annotations.Result;
import org.apache.ibatis.annotations.ResultMap;
import org.apache.ibatis.annotations.Results;
import org.apache.ibatis.annotations.SelectProvider;
import org.mybatis.dynamic.sql.select.render.SelectStatementProvider;
import org.mybatis.dynamic.sql.util.SqlProviderAdapter;

...
    @SelectProvider(type=SqlProviderAdapter.class, method=&quot;select&quot;)
    @Results(id=&quot;AnimalDataResult&quot;, value={
        @Result(column=&quot;id&quot;, property=&quot;id&quot;, id=true),
        @Result(column=&quot;animal_name&quot;, property=&quot;animalName&quot;),
        @Result(column=&quot;brain_weight&quot;, property=&quot;brainWeight&quot;),
        @Result(column=&quot;body_weight&quot;, property=&quot;bodyWeight&quot;)
    })
    List&lt;AnimalData&gt; selectMany(SelectStatementProvider selectStatement);

    @SelectProvider(type=SqlProviderAdapter.class, method=&quot;select&quot;)
    @ResultMap(&quot;AnimalDataResult&quot;)
    AnimalData selectOne(SelectStatementProvider selectStatement);
...

</code></pre></section><section><a id="XML_Mapper_for_Join_Statements"></a>
<h2>XML Mapper for Join Statements</h2>
<p>If you are coding a join, it is likely you will need to code an XML mapper to define the result map. This is due to a
MyBatis limitation - the annotations cannot define a collection mapping. If you have to do this, the Java code looks
like this:</p>

<pre class="prettyprint"><code class="language-java">    @SelectProvider(type=SqlProviderAdapter.class, method=&quot;select&quot;)
    @ResultMap(&quot;SimpleJoinResult&quot;)
    List&lt;OrderMaster&gt; selectMany(SelectStatementProvider selectStatement);
</code></pre>
<p>And the corresponding XML looks like this:</p>

<pre class="prettyprint"><code class="language-xml">&lt;mapper namespace=&quot;examples.joins.JoinMapper&quot;&gt;
  &lt;resultMap id=&quot;SimpleJoinResult&quot; type=&quot;examples.joins.OrderMaster&quot;&gt;
    &lt;id column=&quot;order_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot; /&gt;
    &lt;result column=&quot;order_date&quot; jdbcType=&quot;DATE&quot; property=&quot;orderDate&quot; /&gt;
    &lt;collection property=&quot;details&quot; ofType=&quot;examples.joins.OrderDetail&quot;&gt;
      &lt;id column=&quot;order_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;orderId&quot;/&gt;
      &lt;id column=&quot;line_number&quot; jdbcType=&quot;INTEGER&quot; property=&quot;lineNumber&quot;/&gt;
      &lt;result column=&quot;description&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;description&quot;/&gt;
      &lt;result column=&quot;quantity&quot; jdbcType=&quot;INTEGER&quot; property=&quot;quantity&quot;/&gt;
    &lt;/collection&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<p>Notice that the resultMap is the only element in the XML mapper. This is our recommended practice.</p></section><section><a id="XML_Mapper_for_Select_Statements"></a>
<h2>XML Mapper for Select Statements</h2>
<p>We do not recommend using an XML mapper for select statements, but if you want to do so the SelectStatementProvider
object can be used as a parameter to a MyBatis mapper method directly.</p>
<p>If you are using an XML mapper, the select method should look like this in the Java interface:</p>

<pre class="prettyprint"><code class="language-java">import org.mybatis.dynamic.sql.select.render.SelectStatementProvider;

...
    List&lt;AnimalData&gt; selectMany(SelectStatementProvider selectStatement);
...

</code></pre>
<p>The XML element should look like this:</p>

<pre class="prettyprint"><code class="language-xml">  &lt;resultMap id=&quot;animalResult&quot; type=&quot;examples.animal.data.AnimalData&quot;&gt;
    &lt;id column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot; /&gt;
    &lt;result column=&quot;animal_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;animalName&quot; /&gt;
    &lt;result column=&quot;brain_weight&quot; jdbcType=&quot;DOUBLE&quot; property=&quot;brainWeight&quot; /&gt;
    &lt;result column=&quot;body_weight&quot; jdbcType=&quot;DOUBLE&quot; property=&quot;bodyWeight&quot; /&gt;
  &lt;/resultMap&gt;

  &lt;select id=&quot;selectMany&quot; resultMap=&quot;animalResult&quot;&gt;
    ${selectStatement}
  &lt;/select&gt;
</code></pre></section><section><a id="Notes_on_Order_By"></a>
<h2>Notes on Order By</h2>
<p>Order by phrases can be difficult to calculate when there are aliased columns, aliased tables, unions, and joins.
This library has taken a relatively simple approach:</p>
<ol style="list-style-type: decimal;">

<li>When specifying an SqlColumn in an ORDER BY phrase the library will either write the column alias or the column
name into the ORDER BY phrase.  For the ORDER BY phrase, the table alias (if there is one) will be ignored. Use this
pattern when the ORDER BY column is a member of the select list. For example <code>orderBy(foo)</code>. If the column has an
alias, then it is easiest to use the &#x201c;arbitrary string&#x201d; method with the column alias as shown below.</li>
<li>It is also possible to explicitly specify a table alias for a column in an ORDER BY phrase. Use this pattern when
there is a join, and the ORDER BY column is in two or more tables, and the ORDER BY column is not in the select
list. For example <code>orderBy(sortColumn(&quot;t1&quot;, foo))</code>.</li>
<li>If none of the above use cases meet your needs, then you can specify an arbitrary String to write into the rendered
ORDER BY phrase (see below for an example).</li>
</ol>
<p>In our testing, this caused an issue in only one case.  When there is an outer join and the select list contains
both the left and right join column.  In that case, the workaround is to supply a column alias for both columns.</p>
<p>When using a column function (lower, upper, etc.), then it is customary to give the calculated column an alias so you
will have a predictable result set.  In cases like this there will not be a column to use for an alias.  The library
supports arbitrary values in an ORDER BY expression like this:</p>

<pre class="prettyprint"><code class="language-java">SelectStatementProvider selectStatement = select(substring(gender, 1, 1).as(&quot;ShortGender&quot;), avg(age).as(&quot;AverageAge&quot;))
        .from(person, &quot;a&quot;)
        .groupBy(substring(gender, 1, 1))
        .orderBy(sortColumn(&quot;ShortGender&quot;).descending())
        .build()
        .render(RenderingStrategies.MYBATIS3);
</code></pre>
<p>In this example the <code>substring</code> function is used in both the select list and the GROUP BY expression.  In the ORDER BY
expression, we use the <code>sortColumn</code> function to duplicate the alias given to the column in the select list.</p></section><section><a id="Limit_and_Offset_Support"></a>
<h2>Limit and Offset Support</h2>
<p>Since version 1.1.1 the select statement supports limit and offset for paging (or slicing) queries. You can specify:</p>
<ul>

<li>Limit only</li>
<li>Offset only</li>
<li>Both limit and offset</li>
</ul>
<p>It is important to note that the select renderer writes limit and offset clauses into the generated select statement as
is. The library does not attempt to normalize those values for databases that don't support limit and offset directly.
Therefore, it is very important for users to understand whether the target database supports limit and offset.
If the target database does not support limit and offset, then it is likely that using this support will create SQL
that has runtime errors.</p>
<p>An example follows:</p>

<pre class="prettyprint"><code class="language-java">SelectStatementProvider selectStatement = select(animalData.allColumns())
        .from(animalData)
        .orderBy(id)
        .limit(3)
        .offset(22)
        .build()
        .render(RenderingStrategies.MYBATIS3);
</code></pre></section><section><a id="Fetch_First_Support"></a>
<h2>Fetch First Support</h2>
<p>Since version 1.1.2 the select statement supports fetch first for paging (or slicing) queries. You can specify:</p>
<ul>

<li>Fetch first only</li>
<li>Offset only</li>
<li>Both offset and fetch first</li>
</ul>
<p>Fetch first is an SQL standard and is supported by most databases.</p>
<p>An example follows:</p>

<pre class="prettyprint"><code class="language-java">SelectStatementProvider selectStatement = select(animalData.allColumns())
        .from(animalData)
        .orderBy(id)
        .offset(22)
        .fetchFirst(3).rowsOnly()
        .build()
        .render(RenderingStrategies.MYBATIS3);
</code></pre></section></section>        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Â©      2016â€“2025
<a href="https://www.mybatis.org/">MyBatis.org</a>
</p>
        </div>
      </div>
    </footer>
  </body>
</html>
