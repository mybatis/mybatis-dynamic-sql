<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.8.1 from src/site/markdown/docs/kotlinMyBatis3.md at 19 August 2020
 | Rendered using Apache Maven Fluido Skin 1.7
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20200819" />
    <meta http-equiv="Content-Language" content="en" />
    <title>MyBatis Dynamic SQL &#x2013; Kotlin Support for MyBatis3</title>
    <link rel="stylesheet" href="../css/apache-maven-fluido-1.7.min.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
    <script type="text/javascript" src="../js/apache-maven-fluido-1.7.min.js"></script>
  </head>
  <body class="topBarDisabled">
    <div class="container-fluid">
      <div id="banner">
        <div class="pull-left"><a href="../docs/introduction.html" id="bannerLeft"><h2>MyBatis Dynamic SQL</h2>
</a></div>
        <div class="pull-right"><a href="../../" id="bannerRight" title="MyBatis logo"><img src="http://mybatis.github.io/images/mybatis-logo.png"  alt="MyBatis logo"/></a></div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
        <li id="publishDate">Last Published: 19 August 2020<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 1.2.0</li>
        </ul>
      </div>
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
    <ul class="nav nav-list">
      <li class="nav-header">User's Guide</li>
    <li><a href="../docs/introduction.html" title="Introduction"><span class="none"></span>Introduction</a></li>
    <li><a href="../docs/CHANGELOG.html" title="Change Log"><span class="none"></span>Change Log</a></li>
    <li><a href="../docs/quickStart.html" title="Quick Start"><span class="none"></span>Quick Start</a></li>
    <li><a href="../docs/databaseObjects.html" title="Modeling Database Objects"><span class="none"></span>Modeling Database Objects</a></li>
    <li><a href="../docs/whereClauses.html" title="WHERE Clause Support"><span class="icon-chevron-down"></span>WHERE Clause Support</a>
    <ul class="nav nav-list">
    <li><a href="../docs/conditions.html" title="WHERE Conditions"><span class="none"></span>WHERE Conditions</a></li>
    </ul>
</li>
    <li><a href="../docs/select.html" title="SELECT Statements"><span class="icon-chevron-down"></span>SELECT Statements</a>
    <ul class="nav nav-list">
    <li><a href="../docs/complexQueries.html" title="Complex Queries"><span class="none"></span>Complex Queries</a></li>
    </ul>
</li>
    <li><a href="../docs/delete.html" title="DELETE Statements"><span class="none"></span>DELETE Statements</a></li>
    <li><a href="../docs/insert.html" title="INSERT Statements"><span class="none"></span>INSERT Statements</a></li>
    <li><a href="../docs/update.html" title="UPDATE Statements"><span class="none"></span>UPDATE Statements</a></li>
    <li><a href="../docs/functions.html" title="Database Functions"><span class="none"></span>Database Functions</a></li>
    <li><a href="../docs/mybatis3.html" title="MyBatis3 Support"><span class="none"></span>MyBatis3 Support</a></li>
    <li class="active"><a href="#"><span class="none"></span>Kotlin Support for MyBatis3</a></li>
    <li><a href="../docs/spring.html" title="Spring Support"><span class="none"></span>Spring Support</a></li>
    <li><a href="../docs/kotlinSpring.html" title="Kotlin Support for Spring"><span class="none"></span>Kotlin Support for Spring</a></li>
    <li><a href="../docs/springBatch.html" title="Spring Batch Support"><span class="none"></span>Spring Batch Support</a></li>
    <li><a href="../docs/howItWorks.html" title="How it Works"><span class="none"></span>How it Works</a></li>
    <li><a href="../docs/extending.html" title="Extending the Library"><span class="none"></span>Extending the Library</a></li>
    <li><a href="../docs/codingStandards.html" title="Coding Standards"><span class="none"></span>Coding Standards</a></li>
    <li><a href="../docs/motivation.html" title="Motivation"><span class="none"></span>Motivation</a></li>
      <li class="nav-header">Project Documentation</li>
    <li><a href="../project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="../project-reports.html" title="Project Reports"><span class="icon-chevron-right"></span>Project Reports</a></li>
</ul>
          <hr />
          <div id="poweredBy">
            <div class="clear"></div>
            <div class="clear"></div>
            <div class="clear"></div>
            <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="../images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </div>
        <div id="bodyColumn"  class="span10" >
<h1>Kotlin Support for MyBatis3</h1>
<p>MyBatis Dynamic SQL includes Kotlin extensions that enable an SQL DSL for Kotlin. This is the recommended method of using the library in Kotlin with MyBatis3.</p>
<p>The standard usage patterns for MyBatis Dynamic SQL and MyBatis3 in Java must be modified somewhat for Kotlin. Kotlin interfaces can contain both abstract and non-abstract methods (somewhat similar to Java&#x2019;s default methods in an interface). Using these methods in Kotlin based mapper interfaces will cause a failure with MyBatis because of the underlying Kotlin implementation.</p>
<p>This page will show our recommended pattern for using the MyBatis Dynamic SQL with Kotlin and MyBatis3. The code shown on this page is from the <tt>src/test/kotlin/examples/kotlin/mybatis3/canonical</tt> directory in this repository. That directory contains a complete example of using this library with Kotlin.</p>
<p>All Kotlin support is available in two packages:</p>
<ul>

<li><tt>org.mybatis.dynamic.sql.util.kotlin</tt> - contains extension methods and utilities to enable an idiomatic Kotlin DSL for MyBatis Dynamic SQL. These objects can be used for clients using any execution target (i.e. MyBatis3 or Spring JDBC Templates)</li>
<li><tt>org.mybatis.dynamic.sql.util.kotlin.mybatis3</tt> - contains utilities specifically to simplify MyBatis3 based clients</li>
</ul>
<p>Using the support in these packages, it is possible to create reusable Kotlin classes, interfaces, and extension methods that mimic the code created by MyBatis Generator for Java - but code that is more idiomatic for Kotlin.</p>
<div class="section">
<h2><a name="Kotlin_Dynamic_SQL_Support_Objects"></a>Kotlin Dynamic SQL Support Objects</h2>
<p>Because Kotlin does not support static class members, we recommend a simpler pattern for creating the class containing the support objects. For example:</p>

<div>
<div>
<pre class="source">object PersonDynamicSqlSupport {
    object Person : SqlTable(&quot;Person&quot;) {
        val id = column&lt;Int&gt;(&quot;id&quot;, JDBCType.INTEGER)
        val firstName = column&lt;String&gt;(&quot;first_name&quot;, JDBCType.VARCHAR)
        val lastName = column&lt;String&gt;(&quot;last_name&quot;, JDBCType.VARCHAR)
        val birthDate = column&lt;Date&gt;(&quot;birth_date&quot;, JDBCType.DATE)
        val employed = column&lt;Boolean&gt;(&quot;employed&quot;, JDBCType.VARCHAR, &quot;examples.kotlin.YesNoTypeHandler&quot;)
        val occupation = column&lt;String&gt;(&quot;occupation&quot;, JDBCType.VARCHAR)
        val addressId = column&lt;Int&gt;(&quot;address_id&quot;, JDBCType.INTEGER)
    }
}
</pre></div></div>

<p>This object is a singleton containing the <tt>SqlTable</tt> and <tt>SqlColumn</tt> objects that map to the database table.</p></div>
<div class="section">
<h2><a name="Kotlin_Mappers_for_MyBatis3"></a>Kotlin Mappers for MyBatis3</h2>
<p>If you create a Kotlin mapper interface that includes both abstract and non-abstract methods, MyBatis will be confused and throw errors. By default, Kotlin does not create Java default methods in an interface. For this reason, Kotlin mapper interfaces should only contain the actual MyBatis mapper abstract interface methods. What would normally be coded as default or static methods in a mapper interface should be coded as extension methods in Kotlin. For example, a simple MyBatis mapper could be coded like this:</p>

<div>
<div>
<pre class="source">@Mapper
interface PersonMapper {
    @SelectProvider(type = SqlProviderAdapter::class, method = &quot;select&quot;)
    @Results(id = &quot;PersonRecordResult&quot;, value = [
        Result(column = &quot;a_id&quot;, property = &quot;id&quot;),
        Result(column = &quot;first_name&quot;, property = &quot;firstName&quot;),
        Result(column = &quot;last_name&quot;, property = &quot;lastName&quot;),
        Result(column = &quot;birth_date&quot;, property = &quot;birthDate&quot;),
        Result(column = &quot;employed&quot;, property = &quot;employed&quot;, typeHandler = YesNoTypeHandler::class),
        Result(column = &quot;occupation&quot;, property = &quot;occupation&quot;),
        Result(column = &quot;address_id&quot;, property = &quot;addressId&quot;)
    ])
    fun selectMany(selectStatement: SelectStatementProvider): List&lt;PersonRecord&gt;
}
</pre></div></div>

<p>And then extensions could be added to make a shortcut method as follows:</p>

<div>
<div>
<pre class="source">private val columnList = listOf(id.`as`(&quot;A_ID&quot;), firstName, lastName, birthDate, employed, occupation, addressId)

fun PersonMapper.select(completer: SelectCompleter) =
    selectList(this::selectMany, columnList, Person, completer)
</pre></div></div>

<p>The extension method shows the use of the <tt>SelectCompleter</tt> type alias. This is a DSL extension supplied with the library. We will detail its use below. For now see that the extension method can be used in client code as follows:</p>

<div>
<div>
<pre class="source">val rows = mapper.select {
    where(id, isLessThan(100))
    or (employed, isTrue()) {
        and (occupation, isEqualTo(&quot;Developer&quot;))
    }
    orderBy(id)
}
</pre></div></div>

<p>This shows that the Kotlin support enables a more idiomatic Kotlin DSL.</p></div>
<div class="section">
<h2><a name="Count_Method_Support"></a>Count Method Support</h2>
<p>A count query is a specialized select - it returns a single column - typically a long - and supports joins and a where clause.</p>
<p>Count method support enables the creation of methods that execute a count query allowing a user to specify a where clause at runtime, but abstracting away all other details.</p>
<p>To use this support, we envision creating several methods - one standard mapper method, and other extension methods. The first method is the standard MyBatis Dynamic SQL method that will execute a select statement:</p>

<div>
<div>
<pre class="source">@Mapper
interface PersonMapper {
    @SelectProvider(type = SqlProviderAdapter::class, method = &quot;select&quot;)
    fun count(selectStatement: SelectStatementProvider): Long
}
</pre></div></div>

<p>This is a standard method for MyBatis Dynamic SQL that executes a query and returns a <tt>Long</tt>. The other methods should be extension methods. They will reuse the abstract method and supply everything needed to build the select statement except the where clause:</p>

<div>
<div>
<pre class="source">fun PersonMapper.count(completer: CountCompleter) = // count(*)
    countFrom(this::count, Person, completer)

fun PersonMapper.count(column: BasicColumn, completer: CountCompleter) = // count(column)
    count(this::count, column, Person, completer)

fun PersonMapper.countDistinct(column: BasicColumn, completer: CountCompleter) = // count(distinct column)
    countDistinct(this::count, column, Person, completer)
</pre></div></div>

<p>These methods show the use of <tt>CountCompleter</tt> which is a Kotlin typealias for a function with a receiver that will allow a user to supply a where clause. This also shows use of the Kotlin <tt>countFrom</tt>, <tt>count</tt>, and <tt>countDistinct</tt> methods which are supplied by the library. Those methods will build and execute the select count statements with the supplied where clause. Clients can use the methods as follows:</p>

<div>
<div>
<pre class="source">val rows = mapper.count {
    where(occupation, isNull()) {
        and(employed, isFalse())
    }
}
</pre></div></div>

<p>There is also an extension method that can be used to count all rows in a table:</p>

<div>
<div>
<pre class="source">val rows = mapper.count { allRows() }
</pre></div></div>
</div>
<div class="section">
<h2><a name="Delete_Method_Support"></a>Delete Method Support</h2>
<p>Delete method support enables the creation of methods that execute a delete statement allowing a user to specify a where clause at runtime, but abstracting away all other details.</p>
<p>To use this support, we envision creating two methods - one standard mapper method, and one extension method. The first method is the standard MyBatis Dynamic SQL method that will execute a delete:</p>

<div>
<div>
<pre class="source">@Mapper
interface PersonMapper {
    @DeleteProvider(type = SqlProviderAdapter::class, method = &quot;delete&quot;)
    fun delete(deleteStatement: DeleteStatementProvider): Int
}
</pre></div></div>

<p>This is a standard method for MyBatis Dynamic SQL that executes a delete and returns an <tt>Int</tt> - the number of rows deleted. The second method should be an extension method. It will reuse the abstract method and supply everything needed to build the delete statement except the where clause:</p>

<div>
<div>
<pre class="source">fun PersonMapper.delete(completer: DeleteCompleter) =
    deleteFrom(this::delete, Person, completer)
</pre></div></div>

<p>This method shows the use of <tt>DeleteCompleter</tt> which is a Kotlin typealias for a function with a receiver that will allow a user to supply a where clause. This also shows use of the Kotlin <tt>deleteFrom</tt> method which is supplied by the library. That method will build and execute the delete statement with the supplied where clause. Clients can use the method as follows:</p>

<div>
<div>
<pre class="source">val rows = mapper.delete {
    where(occupation, isNull())
}
</pre></div></div>

<p>There is an extension method that can be used to delete all rows in a table:</p>

<div>
<div>
<pre class="source">val rows = mapper.delete { allRows() }
</pre></div></div>
</div>
<div class="section">
<h2><a name="Insert_Method_Support"></a>Insert Method Support</h2>
<p>Insert method support enables the removal of some of the boilerplate code from insert methods in a mapper interfaces.</p>
<p>To use this support, we envision creating several methods - both standard mapper methods, and other extension methods. The standard mapper methods are standard MyBatis Dynamic SQL methods that will execute an insert:</p>

<div>
<div>
<pre class="source">@Mapper
interface PersonMapper {
    @InsertProvider(type = SqlProviderAdapter::class, method = &quot;insert&quot;)
    fun insert(insertStatement: InsertStatementProvider&lt;PersonRecord&gt;): Int

    @InsertProvider(type = SqlProviderAdapter::class, method = &quot;generalInsert&quot;)
    fun generalInsert(insertStatement: GeneralInsertStatementProvider): Int

    @InsertProvider(type = SqlProviderAdapter::class, method = &quot;insertMultiple&quot;)
    fun insertMultiple(insertStatement: MultiRowInsertStatementProvider&lt;PersonRecord&gt;): Int
}
</pre></div></div>

<p>These methods can be used to implement simplified insert methods with Kotlin extension methods:</p>

<div>
<div>
<pre class="source">fun PersonMapper.insert(record: PersonRecord) =
    insert(this::insert, record, Person) {
        map(id).toProperty(&quot;id&quot;)
        map(firstName).toProperty(&quot;firstName&quot;)
        map(lastName).toProperty(&quot;lastName&quot;)
        map(birthDate).toProperty(&quot;birthDate&quot;)
        map(employed).toProperty(&quot;employed&quot;)
        map(occupation).toProperty(&quot;occupation&quot;)
        map(addressId).toProperty(&quot;addressId&quot;)
    }

fun PersonMapper.generalInsert(completer: GeneralInsertCompleter) =
    insertInto(this::generalInsert, Person, completer)

fun PersonMapper.insertMultiple(vararg records: PersonRecord) =
    insertMultiple(records.toList())

fun PersonMapper.insertMultiple(records: Collection&lt;PersonRecord&gt;) =
    insertMultiple(this::insertMultiple, records, Person) {
        map(id).toProperty(&quot;id&quot;)
        map(firstName).toProperty(&quot;firstName&quot;)
        map(lastName).toProperty(&quot;lastName&quot;)
        map(birthDate).toProperty(&quot;birthDate&quot;)
        map(employed).toProperty(&quot;employed&quot;)
        map(occupation).toProperty(&quot;occupation&quot;)
        map(addressId).toProperty(&quot;addressId&quot;)
    }

fun PersonMapper.insertSelective(record: PersonRecord) =
    insert(this::insert, record, Person) {
        map(id).toPropertyWhenPresent(&quot;id&quot;, record::id)
        map(firstName).toPropertyWhenPresent(&quot;firstName&quot;, record::firstName)
        map(lastName).toPropertyWhenPresent(&quot;lastName&quot;, record::lastName)
        map(birthDate).toPropertyWhenPresent(&quot;birthDate&quot;, record::birthDate)
        map(employed).toPropertyWhenPresent(&quot;employed&quot;, record::employed)
        map(occupation).toPropertyWhenPresent(&quot;occupation&quot;, record::occupation)
        map(addressId).toPropertyWhenPresent(&quot;addressId&quot;, record::addressId)
    }
</pre></div></div>

<p>Note these methods use Kotlin utility methods named <tt>insert</tt>, <tt>insertInto</tt>, and <tt>insertMultiple</tt>. Those methods accept a function with a receiver that will allow column mappings. The methods will build and execute insert statements with the supplied column mappings.</p>
<p>Clients use these methods as follows:</p>

<div>
<div>
<pre class="source">// single insert...
val record = PersonRecord(100, &quot;Joe&quot;, LastName(&quot;Jones&quot;), Date(), true, &quot;Developer&quot;, 1)
val rows = mapper.insert(record)

// general insert...
val rows = mapper.insert {
    set(id).toValue(100)
    set(firstName).toValue(&quot;Joe&quot;)
    set(lastName).toValue(LastName(&quot;Jones&quot;))
    set(employed).toValue(true)
    set(occupation).toValue(&quot;Developer&quot;)
    set(addressId).toValue(1)
    set(birthDate).toValue(Date())
}

// multiple insert...
val record1 = PersonRecord(100, &quot;Joe&quot;, LastName(&quot;Jones&quot;), Date(), true, &quot;Developer&quot;, 1)
val record2 = PersonRecord(101, &quot;Sarah&quot;, LastName(&quot;Smith&quot;), Date(), true, &quot;Architect&quot;, 2)
val rows = mapper.insertMultiple(record1, record2)
</pre></div></div>
</div>
<div class="section">
<h2><a name="Select_Method_Support"></a>Select Method Support</h2>
<p>Select method support enables the creation of methods that execute a query allowing a user to specify a where clause and/or an order by clause and/or pagination clauses at runtime, but abstracting away all other details.</p>
<p>To use this support, we envision creating several methods - two standard mapper methods, and other extension methods. The standard mapper methods are standard MyBatis Dynamic SQL methods that will execute a select statement:</p>

<div>
<div>
<pre class="source">@Mapper
interface PersonMapper {
    @SelectProvider(type = SqlProviderAdapter::class, method = &quot;select&quot;)
    @Results(id = &quot;PersonResult&quot;, value = [
        Result(column = &quot;A_ID&quot;, property = &quot;id&quot;, jdbcType = JdbcType.INTEGER, id = true),
        Result(column = &quot;first_name&quot;, property = &quot;firstName&quot;, jdbcType = JdbcType.VARCHAR),
        Result(column = &quot;last_name&quot;, property = &quot;lastName&quot;, jdbcType = JdbcType.VARCHAR,
                typeHandler = LastNameTypeHandler::class),
        Result(column = &quot;birth_date&quot;, property = &quot;birthDate&quot;, jdbcType = JdbcType.DATE),
        Result(column = &quot;employed&quot;, property = &quot;employed&quot;, jdbcType = JdbcType.VARCHAR,
                typeHandler = YesNoTypeHandler::class),
        Result(column = &quot;occupation&quot;, property = &quot;occupation&quot;, jdbcType = JdbcType.VARCHAR),
        Result(column = &quot;address_id&quot;, property = &quot;addressId&quot;, jdbcType = JdbcType.INTEGER)])
    fun selectMany(selectStatement: SelectStatementProvider): List&lt;PersonRecord&gt;

    @SelectProvider(type = SqlProviderAdapter::class, method = &quot;select&quot;)
    @ResultMap(&quot;PersonResult&quot;)
    fun selectOne(selectStatement: SelectStatementProvider): PersonRecord?
}
</pre></div></div>

<p>These methods can be used to create simplified select methods with Kotlin extension methods:</p>

<div>
<div>
<pre class="source">private val columnList = listOf(id.`as`(&quot;A_ID&quot;), firstName, lastName, birthDate, employed, occupation, addressId)

fun PersonMapper.selectOne(completer: SelectCompleter) =
    selectOne(this::selectOne, columnList, Person, completer)

fun PersonMapper.select(completer: SelectCompleter) =
    selectList(this::selectMany, columnList, Person, completer)

fun PersonMapper.selectDistinct(completer: SelectCompleter) =
    selectDistinct(this::selectMany, columnList, Person, completer)
</pre></div></div>

<p>These methods show the use of <tt>SelectCompleter</tt> which is a which is a Kotlin typealias for a function with a receiver that will allow a user to supply a where clause. The <tt>selectMany</tt> method can be used to implement generalized select methods where a user can specify a where clause and/or an order by clause. Typically we recommend two of these methods - for select, and select distinct. The <tt>selectOne</tt> method is used to create a generalized select method where a user can specify a where clause. These methods also show the use of the built in Kotlin functions <tt>selectDistinct</tt>, <tt>selectList</tt>, and <tt>selectOne</tt>. These functions build and execute select statements, and help to avoid platform type issues in Kotlin. They enable the Kotlin compiler to correctly infer the result type (either <tt>PersonRecord?</tt> or <tt>List&lt;PersonRecord&gt;</tt> in this case).</p>
<p>The general <tt>selectOne</tt> method can also be used to implement a <tt>selectByPrimaryKey</tt> method:</p>

<div>
<div>
<pre class="source">fun PersonMapper.selectByPrimaryKey(id_: Int) =
    selectOne {
        where(id, isEqualTo(id_))
    }
</pre></div></div>

<p>Clients can use the methods as follows:</p>

<div>
<div>
<pre class="source">val rows = mapper.select {
    where(firstName, isIn(&quot;Fred&quot;, &quot;Barney&quot;))
    orderBy(id)
    limit(3)
}
</pre></div></div>

<p>There is a utility method that will select all rows in a table:</p>

<div>
<div>
<pre class="source">val rows = mapper.select { allRows() }
</pre></div></div>

<p>The following query will select all rows in a specified order:</p>

<div>
<div>
<pre class="source">val rows = mapper.select {
    allRows()
    orderBy(lastName, firstName)
}
</pre></div></div>
</div>
<div class="section">
<h2><a name="Update_Method_Support"></a>Update Method Support</h2>
<p>Update method support enables the creation of methods that execute an update allowing a user to specify SET clauses and/or a WHERE clause, but abstracting away all other details.</p>
<p>To use this support, we envision creating several methods - one standard mapper method, and other extension methods. The standard mapper method is a standard MyBatis Dynamic SQL methods that will execute an update:</p>

<div>
<div>
<pre class="source">@Mapper
interface PersonMapper {
    @UpdateProvider(type = SqlProviderAdapter::class, method = &quot;update&quot;)
    fun update(updateStatement: UpdateStatementProvider): Int
}
</pre></div></div>

<p>This is a standard method for MyBatis Dynamic SQL that executes an update and returns an <tt>int</tt> - the number of rows updated. The extension methods will reuse this method and supply everything needed to build the update statement except the values and the where clause:</p>

<div>
<div>
<pre class="source">fun PersonMapper.update(completer: UpdateCompleter) =
    update(this::update, Person, completer)
</pre></div></div>

<p>This extension method shows the use of <tt>UpdateCompleter</tt> which is a Kotlin typealias for a function with a receiver that will allow a user to supply values and a where clause. This also shows use of the Kotlin <tt>update</tt> method which is supplied by the library. That method will build and execute the update statement with the supplied values and where clause. Clients can use the method as follows:</p>

<div>
<div>
<pre class="source">val rows = mapper.update {
    set(occupation).equalTo(&quot;Programmer&quot;)
    where(id, isEqualTo(100))
}
</pre></div></div>

<p>All rows in a table can be updated by simply omitting the where clause:</p>

<div>
<div>
<pre class="source">val rows = mapper.update {
    set(occupation).equalTo(&quot;Programmer&quot;)
}
</pre></div></div>

<p>It is also possible to write a utility method that will set values. For example:</p>

<div>
<div>
<pre class="source">fun KotlinUpdateBuilder.updateSelectiveColumns(record: PersonRecord) =
    apply {
        set(id).equalToWhenPresent(record::id)
        set(firstName).equalToWhenPresent(record::firstName)
        set(lastName).equalToWhenPresent(record::lastName)
        set(birthDate).equalToWhenPresent(record::birthDate)
        set(employed).equalToWhenPresent(record::employed)
        set(occupation).equalToWhenPresent(record::occupation)
        set(addressId).equalToWhenPresent(record::addressId)
    }
</pre></div></div>

<p>This method will selectively set values if corresponding fields in a record are non null. This method can be used as follows:</p>

<div>
<div>
<pre class="source">val rows = mapper.update {
    updateSelectiveColumns(updateRecord)
    where(id, isEqualTo(100))
}
</pre></div></div>
</div>
<div class="section">
<h2><a name="Join_Support"></a>Join Support</h2>
<p>There are extension functions that support building a reusable select method based on a join. In this way, you can create the start of the select statement (the column list and join specifications) and allow the user to supply where clauses and other parts of a select statement. For example, you could code a mapper extension method like this:</p>

<div>
<div>
<pre class="source">fun PersonWithAddressMapper.select(completer: SelectCompleter): List&lt;PersonWithAddress&gt; {
    val start = select(columnList).from(Person, &quot;p&quot;) {
        join(Address, &quot;a&quot;) {
            on(Person.addressId, equalTo(Address.id))
        }
    }
    return selectList(this::selectMany, start, completer)
}
</pre></div></div>

<p>This method creates the start of a select statement with a join, and accepts user input to complete the statement. This shows use of and overloaded <tt>selectList</tt> method that accepts the start of a select statement and a completer. Like other select methods, this method can be used as follows:</p>

<div>
<div>
<pre class="source">val records = mapper.select {
    where(id, isLessThan(100))
    limit(5)
}
</pre></div></div></div>
        </div>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Copyright &copy;2016&#x2013;2020
<a href="http://www.mybatis.org/">MyBatis.org</a>.
All rights reserved.</p>
        </div>
      </div>
    </footer>
  </body>
</html>
